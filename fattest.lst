CCS PCH C Compiler, Version 4.038, 15507               10-mar-10 00:02

               Filename: D:\Proyectos\Electrónica\fatlib-1.2\fattest.lst

               ROM used: 8204 bytes (25%)
                         Largest free fragment is 24564
               RAM used: 677 (33%) at main() level
                         788 (38%) worst case
               Stack:    5 locations

*
0000:  GOTO   16B6
.................... #include "fattest.h" 
.................... #include <18F2550.h> 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
....................  
.................... #use delay(clock=20000000) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_B7,rcv=PIN_B6,bits=8) 
*
0430:  BCF    F93.7
0432:  BCF    F8A.7
0434:  MOVLW  08
0436:  MOVWF  01
0438:  BRA    043A
043A:  NOP   
043C:  BSF    01.7
043E:  BRA    0460
0440:  BCF    01.7
0442:  MOVLB  2
0444:  RRCF   xB1,F
0446:  MOVLB  0
0448:  BTFSC  FD8.0
044A:  BSF    F8A.7
044C:  BTFSS  FD8.0
044E:  BCF    F8A.7
0450:  BSF    01.6
0452:  BRA    0460
0454:  BCF    01.6
0456:  DECFSZ 01,F
0458:  BRA    0442
045A:  BRA    045C
045C:  NOP   
045E:  BSF    F8A.7
0460:  MOVLW  08
0462:  MOVWF  FE9
0464:  DECFSZ FE9,F
0466:  BRA    0464
0468:  NOP   
046A:  BTFSC  01.7
046C:  BRA    0440
046E:  BTFSC  01.6
0470:  BRA    0454
0472:  RETLW  00
.................... #use SPI(FORCE_HW) 
....................  
.................... #include "mmcdriver.h" 
.................... #define MMC_CS PIN_A5 
....................  
.................... int mmc_response(unsigned char response) 
.................... { 
....................    unsigned long count = 0x0FFF; 
0474:  MOVLW  FF
0476:  MOVLB  3
0478:  MOVWF  x0D
047A:  MOVLW  0F
047C:  MOVWF  x0E
....................    while (spi_read(0xFF) != response && --count > 0); 
047E:  MOVF   FC9,W
0480:  MOVLW  FF
0482:  MOVWF  FC9
0484:  BTFSS  FC7.0
0486:  BRA    0484
0488:  MOVF   x0C,W
048A:  SUBWF  FC9,W
048C:  BZ    049C
048E:  MOVF   x0D,W
0490:  BTFSC  FD8.2
0492:  DECF   x0E,F
0494:  DECFSZ x0D,F
0496:  BRA    047E
0498:  MOVF   x0E,F
049A:  BNZ   047E
....................     
....................    if (count == 0) 
049C:  MOVF   x0D,F
049E:  BNZ   04AC
04A0:  MOVF   x0E,F
04A2:  BNZ   04AC
....................    { 
....................       return 1; 
04A4:  MOVLW  01
04A6:  MOVWF  01
04A8:  BRA    04B2
....................    } 
....................    else 
04AA:  BRA    04B2
....................    { 
....................       return 0; 
04AC:  MOVLW  00
04AE:  MOVWF  01
04B0:  BRA    04B2
....................    } 
.................... } 
04B2:  MOVLB  0
04B4:  RETLW  00
....................  
.................... char mmc_open_block(int32 block_number) 
.................... { 
....................    int8 addr[4]; 
....................     
....................    output_low(MMC_CS); 
*
06F4:  BCF    F92.5
06F6:  BCF    F89.5
....................  
....................    block_number *= 512; 
06F8:  BCF    FD8.0
06FA:  MOVFF  306,307
06FE:  MOVFF  305,306
0702:  MOVFF  304,305
0706:  MOVLB  3
0708:  CLRF   x04
070A:  RLCF   x05,F
070C:  RLCF   x06,F
070E:  RLCF   x07,F
....................    addr[0] = MAKE8(block_number, 3); 
0710:  MOVFF  307,308
....................    addr[1] = MAKE8(block_number, 2); 
0714:  MOVFF  306,309
....................    addr[2] = MAKE8(block_number, 1); 
0718:  MOVFF  305,30A
....................    addr[3] = MAKE8(block_number, 0); 
071C:  MOVFF  304,30B
....................     
....................    SPI_WRITE(0x51); 
0720:  MOVF   FC9,W
0722:  MOVLW  51
0724:  MOVWF  FC9
0726:  BTFSS  FC7.0
0728:  BRA    0726
....................    SPI_WRITE(addr[0]); 
072A:  MOVF   FC9,W
072C:  MOVFF  308,FC9
0730:  BTFSS  FC7.0
0732:  BRA    0730
....................    SPI_WRITE(addr[1]); 
0734:  MOVF   FC9,W
0736:  MOVFF  309,FC9
073A:  BTFSS  FC7.0
073C:  BRA    073A
....................    SPI_WRITE(addr[2]); 
073E:  MOVF   FC9,W
0740:  MOVFF  30A,FC9
0744:  BTFSS  FC7.0
0746:  BRA    0744
....................    SPI_WRITE(addr[3]); 
0748:  MOVF   FC9,W
074A:  MOVFF  30B,FC9
074E:  BTFSS  FC7.0
0750:  BRA    074E
....................    SPI_WRITE(0xFF); 
0752:  MOVF   FC9,W
0754:  MOVLW  FF
0756:  MOVWF  FC9
0758:  BTFSS  FC7.0
075A:  BRA    0758
....................     
....................    if((mmc_response(0x00))==1) return 1; 
075C:  CLRF   x0C
075E:  MOVLB  0
0760:  RCALL  0474
0762:  DECFSZ 01,W
0764:  BRA    076C
0766:  MOVLW  01
0768:  MOVWF  01
076A:  BRA    0784
....................    if((mmc_response(0xFE))==1) return 1; 
076C:  MOVLW  FE
076E:  MOVLB  3
0770:  MOVWF  x0C
0772:  MOVLB  0
0774:  RCALL  0474
0776:  DECFSZ 01,W
0778:  BRA    0780
077A:  MOVLW  01
077C:  MOVWF  01
077E:  BRA    0784
....................     
....................    return 0; 
0780:  MOVLW  00
0782:  MOVWF  01
.................... } 
0784:  GOTO   07C0 (RETURN)
....................  
.................... void mmc_close_block(void){ 
....................    SPI_READ(0xFF); 
0788:  MOVF   FC9,W
078A:  MOVLW  FF
078C:  MOVWF  FC9
078E:  BTFSS  FC7.0
0790:  BRA    078E
....................    SPI_READ(0xFF); 
0792:  MOVF   FC9,W
0794:  MOVLW  FF
0796:  MOVWF  FC9
0798:  BTFSS  FC7.0
079A:  BRA    0798
....................    output_high(MMC_CS); 
079C:  BCF    F92.5
079E:  BSF    F89.5
....................    SPI_WRITE(0xFF); 
07A0:  MOVF   FC9,W
07A2:  MOVLW  FF
07A4:  MOVWF  FC9
07A6:  BTFSS  FC7.0
07A8:  BRA    07A6
.................... } 
07AA:  GOTO   07F2 (RETURN)
....................  
.................... int mmc_read_block_to_serial(int16 block_number) 
.................... { 
....................    unsigned long i; 
....................    unsigned long j; 
....................     
....................    printf("\r\n"); 
....................    mmc_open_block(block_number); 
....................    for (i = 0; i < 32; i++) 
....................    { 
....................       for (j = 0; j < 16; j++) 
....................       { 
....................          printf("%2X ", spi_read(0xFF)); 
....................       } 
....................       printf("\r\n"); 
....................    } 
....................    mmc_close_block(); 
....................     
....................    return 0; 
.................... } 
....................  
.................... int mmc_init() 
.................... { 
....................    int i; 
....................     
....................    printf("Configuring the SPI module...\r\n"); 
*
04B6:  MOVLB  2
04B8:  CLRF   xA1
04BA:  MOVF   xA1,W
04BC:  MOVLB  0
04BE:  RCALL  0004
04C0:  MOVLB  2
04C2:  INCF   xA1,F
04C4:  MOVWF  00
04C6:  MOVWF  xB1
04C8:  MOVLB  0
04CA:  RCALL  0430
04CC:  MOVLW  1A
04CE:  MOVLB  2
04D0:  SUBWF  xA1,W
04D2:  BNZ   04BA
04D4:  MOVLW  03
04D6:  MOVWF  xA2
04D8:  MOVLW  2E
04DA:  MOVWF  xB1
04DC:  MOVLB  0
04DE:  RCALL  0430
04E0:  MOVLB  2
04E2:  DECFSZ xA2,F
04E4:  BRA    04D8
04E6:  MOVLW  0D
04E8:  MOVWF  xB1
04EA:  MOVLB  0
04EC:  RCALL  0430
04EE:  MOVLW  0A
04F0:  MOVLB  2
04F2:  MOVWF  xB1
04F4:  MOVLB  0
04F6:  RCALL  0430
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
04F8:  BCF    FC6.5
04FA:  BCF    F94.7
04FC:  BSF    F93.0
04FE:  BCF    F93.1
0500:  MOVLW  20
0502:  MOVWF  FC6
0504:  MOVLW  40
0506:  MOVWF  FC7
....................    //setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H); 
....................     
....................    printf("Initializing MMC/SD memory card...\r\n"); 
0508:  MOVLB  2
050A:  CLRF   xA1
050C:  MOVF   xA1,W
050E:  MOVLB  0
0510:  RCALL  0032
0512:  MOVLB  2
0514:  INCF   xA1,F
0516:  MOVWF  00
0518:  MOVWF  xB1
051A:  MOVLB  0
051C:  RCALL  0430
051E:  MOVLW  1F
0520:  MOVLB  2
0522:  SUBWF  xA1,W
0524:  BNZ   050C
0526:  MOVLW  03
0528:  MOVWF  xA2
052A:  MOVLW  2E
052C:  MOVWF  xB1
052E:  MOVLB  0
0530:  RCALL  0430
0532:  MOVLB  2
0534:  DECFSZ xA2,F
0536:  BRA    052A
0538:  MOVLW  0D
053A:  MOVWF  xB1
053C:  MOVLB  0
053E:  RCALL  0430
0540:  MOVLW  0A
0542:  MOVLB  2
0544:  MOVWF  xB1
0546:  MOVLB  0
0548:  RCALL  0430
....................  
....................    output_high(MMC_CS); 
054A:  BCF    F92.5
054C:  BSF    F89.5
....................    for(i = 0; i < 10; i++) 
054E:  MOVLB  2
0550:  CLRF   xA0
0552:  MOVF   xA0,W
0554:  SUBLW  09
0556:  BNC   0566
....................    { 
....................       spi_write(0xFF); 
0558:  MOVF   FC9,W
055A:  MOVLW  FF
055C:  MOVWF  FC9
055E:  BTFSS  FC7.0
0560:  BRA    055E
....................    } 
0562:  INCF   xA0,F
0564:  BRA    0552
....................    output_low(MMC_CS); 
0566:  BCF    F92.5
0568:  BCF    F89.5
....................     
....................    spi_write(0x40); 
056A:  MOVF   FC9,W
056C:  MOVLW  40
056E:  MOVWF  FC9
0570:  BTFSS  FC7.0
0572:  BRA    0570
....................    spi_write(0x00); 
0574:  MOVF   FC9,W
0576:  CLRF   FC9
0578:  BTFSS  FC7.0
057A:  BRA    0578
....................    spi_write(0x00); 
057C:  MOVF   FC9,W
057E:  CLRF   FC9
0580:  BTFSS  FC7.0
0582:  BRA    0580
....................    spi_write(0x00); 
0584:  MOVF   FC9,W
0586:  CLRF   FC9
0588:  BTFSS  FC7.0
058A:  BRA    0588
....................    spi_write(0x00); 
058C:  MOVF   FC9,W
058E:  CLRF   FC9
0590:  BTFSS  FC7.0
0592:  BRA    0590
....................  
....................    spi_write(0x95); 
0594:  MOVF   FC9,W
0596:  MOVLW  95
0598:  MOVWF  FC9
059A:  BTFSS  FC7.0
059C:  BRA    059A
....................     
....................    if (mmc_response(0x01) == 1) 
059E:  MOVLW  01
05A0:  MOVLB  3
05A2:  MOVWF  x0C
05A4:  MOVLB  0
05A6:  RCALL  0474
05A8:  DECFSZ 01,W
05AA:  BRA    05D0
....................    { 
....................       printf("Timeout (1)!\r\n"); 
05AC:  MOVLB  2
05AE:  CLRF   xA1
05B0:  MOVF   xA1,W
05B2:  MOVLB  0
05B4:  RCALL  0064
05B6:  MOVLB  2
05B8:  INCF   xA1,F
05BA:  MOVWF  00
05BC:  MOVWF  xB1
05BE:  MOVLB  0
05C0:  RCALL  0430
05C2:  MOVLW  0E
05C4:  MOVLB  2
05C6:  SUBWF  xA1,W
05C8:  BNZ   05B0
....................       return 1; 
05CA:  MOVLW  01
05CC:  MOVWF  01
05CE:  BRA    06EE
....................    } 
....................  
....................    i = 0; 
05D0:  MOVLB  2
05D2:  CLRF   xA0
....................    while((i < 255) && (mmc_response(0x00) == 1)) 
....................    { 
05D4:  INCFSZ xA0,W
05D6:  BRA    05DA
05D8:  BRA    0626
05DA:  MOVLB  3
05DC:  CLRF   x0C
05DE:  MOVLB  0
05E0:  RCALL  0474
05E2:  DECFSZ 01,W
05E4:  BRA    05E8
05E6:  BRA    05EC
05E8:  MOVLB  2
05EA:  BRA    0626
....................       spi_write(0x41); 
05EC:  MOVF   FC9,W
05EE:  MOVLW  41
05F0:  MOVWF  FC9
05F2:  BTFSS  FC7.0
05F4:  BRA    05F2
....................       spi_write(0x00); 
05F6:  MOVF   FC9,W
05F8:  CLRF   FC9
05FA:  BTFSS  FC7.0
05FC:  BRA    05FA
....................       spi_write(0x00); 
05FE:  MOVF   FC9,W
0600:  CLRF   FC9
0602:  BTFSS  FC7.0
0604:  BRA    0602
....................       spi_write(0x00); 
0606:  MOVF   FC9,W
0608:  CLRF   FC9
060A:  BTFSS  FC7.0
060C:  BRA    060A
....................       spi_write(0x00); 
060E:  MOVF   FC9,W
0610:  CLRF   FC9
0612:  BTFSS  FC7.0
0614:  BRA    0612
....................       spi_write(0xFF); 
0616:  MOVF   FC9,W
0618:  MOVLW  FF
061A:  MOVWF  FC9
061C:  BTFSS  FC7.0
061E:  BRA    061C
....................       i++; 
0620:  MOVLB  2
0622:  INCF   xA0,F
....................    } 
0624:  BRA    05D4
....................     
....................    if(i >= 254) 
0626:  MOVF   xA0,W
0628:  SUBLW  FD
062A:  BC    064E
....................    { 
....................       printf("Timeout (2)!\r\n"); 
062C:  CLRF   xA1
062E:  MOVF   xA1,W
0630:  MOVLB  0
0632:  RCALL  0084
0634:  MOVLB  2
0636:  INCF   xA1,F
0638:  MOVWF  00
063A:  MOVWF  xB1
063C:  MOVLB  0
063E:  RCALL  0430
0640:  MOVLW  0E
0642:  MOVLB  2
0644:  SUBWF  xA1,W
0646:  BNZ   062E
....................       return 1; 
0648:  MOVLW  01
064A:  MOVWF  01
064C:  BRA    06EE
....................    } 
....................     
....................    output_high(MMC_CS); 
064E:  BCF    F92.5
0650:  BSF    F89.5
....................    spi_write(0xFF); 
0652:  MOVF   FC9,W
0654:  MOVLW  FF
0656:  MOVWF  FC9
0658:  BTFSS  FC7.0
065A:  BRA    0658
....................    output_low(MMC_CS); 
065C:  BCF    F92.5
065E:  BCF    F89.5
....................  
....................    SPI_WRITE(0x50); 
0660:  MOVF   FC9,W
0662:  MOVLW  50
0664:  MOVWF  FC9
0666:  BTFSS  FC7.0
0668:  BRA    0666
....................    SPI_WRITE(0x00); 
066A:  MOVF   FC9,W
066C:  CLRF   FC9
066E:  BTFSS  FC7.0
0670:  BRA    066E
....................    SPI_WRITE(0x00); 
0672:  MOVF   FC9,W
0674:  CLRF   FC9
0676:  BTFSS  FC7.0
0678:  BRA    0676
....................    SPI_WRITE(0x02); 
067A:  MOVF   FC9,W
067C:  MOVLW  02
067E:  MOVWF  FC9
0680:  BTFSS  FC7.0
0682:  BRA    0680
....................    SPI_WRITE(0x00); 
0684:  MOVF   FC9,W
0686:  CLRF   FC9
0688:  BTFSS  FC7.0
068A:  BRA    0688
....................    SPI_WRITE(0xFF); 
068C:  MOVF   FC9,W
068E:  MOVLW  FF
0690:  MOVWF  FC9
0692:  BTFSS  FC7.0
0694:  BRA    0692
....................     
....................    if((mmc_response(0x00)) == 1) 
0696:  MOVLB  3
0698:  CLRF   x0C
069A:  MOVLB  0
069C:  RCALL  0474
069E:  DECFSZ 01,W
06A0:  BRA    06C8
....................    { 
....................       printf("Timeout (3)!\r\n"); 
06A2:  MOVLB  2
06A4:  CLRF   xA1
06A6:  MOVF   xA1,W
06A8:  MOVLB  0
06AA:  RCALL  00A4
06AC:  MOVLB  2
06AE:  INCF   xA1,F
06B0:  MOVWF  00
06B2:  MOVWF  xB1
06B4:  MOVLB  0
06B6:  RCALL  0430
06B8:  MOVLW  0E
06BA:  MOVLB  2
06BC:  SUBWF  xA1,W
06BE:  BNZ   06A6
....................       return 1; 
06C0:  MOVLW  01
06C2:  MOVWF  01
06C4:  BRA    06EE
06C6:  MOVLB  0
....................    } 
....................     
....................    output_high(MMC_CS); 
06C8:  BCF    F92.5
06CA:  BSF    F89.5
....................     
....................    printf("The MMC/SD memory card has been initialized successfuly.\r\n"); 
06CC:  MOVLB  2
06CE:  CLRF   xA1
06D0:  MOVF   xA1,W
06D2:  MOVLB  0
06D4:  RCALL  00C4
06D6:  MOVLB  2
06D8:  INCF   xA1,F
06DA:  MOVWF  00
06DC:  MOVWF  xB1
06DE:  MOVLB  0
06E0:  RCALL  0430
06E2:  MOVLW  3A
06E4:  MOVLB  2
06E6:  SUBWF  xA1,W
06E8:  BNZ   06D0
....................    return 0; 
06EA:  MOVLW  00
06EC:  MOVWF  01
.................... } 
06EE:  MOVLB  0
06F0:  GOTO   16E6 (RETURN)
....................  
.................... #include "fatdriver.h" 
.................... // Boolean values if not defined 
.................... #ifndef TRUE 
.................... #define TRUE 1 
.................... #endif 
....................  
....................  
.................... #ifndef FALSE 
.................... #define FALSE 0 
.................... #endif 
....................  
.................... // Constants used when determining Directory Entry types 
.................... #define EOD 0 
.................... #define UNUSED 1 
.................... #define LFNAME 2 
.................... #define NFNAME 3 
.................... #define NDNAME 4 //Normal directory 
....................  
.................... // Global constants used by the FAT32 file system 
.................... #define BUFFER_SIZE 512 
.................... #define DIRENTRY_SIZE 32 
.................... #define FILENAME_SIZE 12 
.................... #define FILEDATA_SIZE 32 
.................... #define PARTITION_ENTRY_SIZE  16 
....................  
.................... #define FIRST_PARTITION_ENTRY 0x1BE 
....................  
.................... // Buffers used to temporarily save the obtained data 
.................... BYTE SectorBuffer[BUFFER_SIZE]; 
.................... BYTE DirEntry[DIRENTRY_SIZE]; 
....................  
.................... // Volume ID information 
.................... unsigned int16 BytesPerSector; 
.................... unsigned BYTE  SectorsPerCluster; 
.................... unsigned int16 NumberOfReservedSectors; 
.................... unsigned BYTE  NumberOfFATs; 
.................... unsigned int32 SectorsPerFAT; 
.................... unsigned int32 RootDirectoryFirstCluster; 
....................  
.................... // Information related to partitions and FAT table 
.................... unsigned int32 PartitionLBABegin; 
.................... unsigned int32 FatBeginLBA; 
.................... //unsigned int32 ClusterBeginLBA; 
.................... unsigned int32 DataBeginLBA; 
.................... unsigned int8  FAT16Offset; 
....................  
.................... // Variables used to store the position of current entry 
.................... // when reading directory contents. 
.................... unsigned int32 DirectoryCurrentCluster; 
.................... unsigned int32 DirectoryCurrentLBA; 
.................... unsigned BYTE DirectoryCurrentDirEntry; 
.................... unsigned int16 DirectoryCurrentSector; 
.................... unsigned BOOLEAN DirectoryOpened; 
.................... unsigned BOOLEAN EODReached; 
....................  
.................... // Variables used to store file information when reading 
.................... unsigned int32 FileCurrentCluster; 
.................... unsigned int32 FileCurrentLBA; 
.................... unsigned int16 FileCurrentSector; 
.................... unsigned int32 FileLengthCount; 
.................... unsigned int16 FileSectorPosition; 
.................... unsigned BOOLEAN FileOpened; 
....................  
.................... // File descriptor structure 
.................... typedef struct 
.................... { 
....................    unsigned BYTE Name[FILENAME_SIZE]; 
....................    unsigned int8  Attributes; 
....................    unsigned int32 FirstLBA; 
....................    unsigned int32 Size; 
....................    unsigned int32 FirstCluster; 
.................... } FILEDESCRIPTOR; 
....................  
.................... //A partition Entry structure 
.................... typedef struct 
.................... {    
....................    unsigned short IsValid; 
....................    unsigned short IsFAT32; 
....................    BYTE Type; 
.................... } PARTITIONENTRY; 
....................  
.................... // File data structure 
.................... typedef struct 
.................... { 
....................    unsigned BYTE Buffer[FILEDATA_SIZE]; 
....................    unsigned int16 BytesRead; 
....................    unsigned BOOLEAN EOF; 
.................... } FILEDATA; 
....................  
.................... PARTITIONENTRY pEntry; 
....................  
.................... // -- Start of Code Section ------------- 
....................  
.................... BOOLEAN ReadSector(unsigned int32 lba) 
.................... { 
....................    unsigned long i; 
....................     
....................    mmc_open_block(lba); 
*
07AE:  MOVFF  301,307
07B2:  MOVFF  300,306
07B6:  MOVFF  2FF,305
07BA:  MOVFF  2FE,304
07BE:  BRA    06F4
....................    for (i = 0; i < BUFFER_SIZE; i++) 
07C0:  MOVLB  3
07C2:  CLRF   x03
07C4:  CLRF   x02
07C6:  MOVF   x03,W
07C8:  SUBLW  01
07CA:  BNC   07EE
....................    { 
....................       SectorBuffer[i] = spi_read(0xFF); 
07CC:  MOVLW  05
07CE:  ADDWF  x02,W
07D0:  MOVWF  FE9
07D2:  MOVLW  00
07D4:  ADDWFC x03,W
07D6:  MOVWF  FEA
07D8:  MOVF   FC9,W
07DA:  MOVLW  FF
07DC:  MOVWF  FC9
07DE:  BTFSS  FC7.0
07E0:  BRA    07DE
07E2:  MOVFF  FC9,FEF
....................    } 
07E6:  INCF   x02,F
07E8:  BTFSC  FD8.2
07EA:  INCF   x03,F
07EC:  BRA    07C6
....................    mmc_close_block(); 
07EE:  MOVLB  0
07F0:  BRA    0788
....................     
....................    return TRUE; 
07F2:  MOVLW  01
07F4:  MOVWF  01
.................... } 
07F6:  RETLW  00
....................  
.................... void ReadDirEntry(BYTE num) 
.................... { 
....................    // Calculate Directory Entry offset according to Directory Entry number 
....................    unsigned int16 offset; 
....................    unsigned int16 i; 
....................     
....................    offset = (unsigned int16)num * DIRENTRY_SIZE; 
*
0E84:  MOVLB  2
0E86:  CLRF   xC6
0E88:  RLCF   xC0,W
0E8A:  MOVWF  xC1
0E8C:  RLCF   xC6,W
0E8E:  MOVWF  xC2
0E90:  RLCF   xC1,F
0E92:  RLCF   xC2,F
0E94:  RLCF   xC1,F
0E96:  RLCF   xC2,F
0E98:  RLCF   xC1,F
0E9A:  RLCF   xC2,F
0E9C:  RLCF   xC1,F
0E9E:  RLCF   xC2,F
0EA0:  MOVLW  E0
0EA2:  ANDWF  xC1,F
....................    // Copy the Directory Entry data to the DirEntry vector in order to 
....................    // analyze the data later 
....................    for (i = 0; i < DIRENTRY_SIZE; i++) 
0EA4:  CLRF   xC4
0EA6:  CLRF   xC3
0EA8:  MOVF   xC4,F
0EAA:  BNZ   0EEE
0EAC:  MOVF   xC3,W
0EAE:  SUBLW  1F
0EB0:  BNC   0EEE
....................    { 
....................        DirEntry[i] = SectorBuffer[offset + i]; 
0EB2:  MOVLW  05
0EB4:  ADDWF  xC3,W
0EB6:  MOVWF  01
0EB8:  MOVLW  02
0EBA:  ADDWFC xC4,W
0EBC:  MOVWF  03
0EBE:  MOVF   xC3,W
0EC0:  ADDWF  xC1,W
0EC2:  MOVWF  xC7
0EC4:  MOVF   xC4,W
0EC6:  ADDWFC xC2,W
0EC8:  MOVWF  xC8
0ECA:  MOVLW  05
0ECC:  ADDWF  xC7,W
0ECE:  MOVWF  FE9
0ED0:  MOVLW  00
0ED2:  ADDWFC xC8,W
0ED4:  MOVWF  FEA
0ED6:  MOVFF  FEF,2C9
0EDA:  MOVFF  03,FEA
0EDE:  MOVFF  01,FE9
0EE2:  MOVFF  2C9,FEF
....................    } 
0EE6:  INCF   xC3,F
0EE8:  BTFSC  FD8.2
0EEA:  INCF   xC4,F
0EEC:  BRA    0EA8
.................... } 
0EEE:  MOVLB  0
0EF0:  GOTO   12C6 (RETURN)
....................  
.................... BOOLEAN GetEntry(unsigned int16 startingPos) 
.................... { 
....................    pEntry.IsValid = FALSE; 
*
07F8:  MOVLB  2
07FA:  BCF    x5C.0
....................  
....................    //Partition must exists and be ACTIVE 
....................    if (SectorBuffer[startingPos] != 0x80) 
07FC:  MOVLW  05
07FE:  ADDWF  xA3,W
0800:  MOVWF  FE9
0802:  MOVLW  00
0804:  ADDWFC xA4,W
0806:  MOVWF  FEA
0808:  MOVF   FEF,W
080A:  SUBLW  80
080C:  BZ    0814
....................       return FALSE; 
080E:  MOVLW  00
0810:  MOVWF  01
0812:  BRA    08E4
....................        
....................    pEntry.Type = SectorBuffer[startingPos + 4]; 
0814:  MOVLW  04
0816:  ADDWF  xA3,W
0818:  MOVWF  xA5
081A:  MOVLW  00
081C:  ADDWFC xA4,W
081E:  MOVWF  xA6
0820:  MOVLW  05
0822:  ADDWF  xA5,W
0824:  MOVWF  FE9
0826:  MOVLW  00
0828:  ADDWFC xA6,W
082A:  MOVWF  FEA
082C:  MOVFF  FEF,25D
....................     
....................    if (pEntry.Type == 0x04 || pEntry.Type == 0x06 || pEntry.Type == 0x0E) 
0830:  MOVF   x5D,W
0832:  SUBLW  04
0834:  BZ    0842
0836:  MOVF   x5D,W
0838:  SUBLW  06
083A:  BZ    0842
083C:  MOVF   x5D,W
083E:  SUBLW  0E
0840:  BNZ   0846
....................    { 
....................       pEntry.IsFAT32 = FALSE; 
0842:  BCF    x5C.1
....................       pEntry.IsValid = TRUE; 
0844:  BSF    x5C.0
....................    } 
....................     
....................    if (pEntry.Type == 0x0B || pEntry.Type == 0x0C) 
0846:  MOVF   x5D,W
0848:  SUBLW  0B
084A:  BZ    0852
084C:  MOVF   x5D,W
084E:  SUBLW  0C
0850:  BNZ   0856
....................    { 
....................       pEntry.IsFAT32 = TRUE; 
0852:  BSF    x5C.1
....................       pEntry.IsValid = TRUE; 
0854:  BSF    x5C.0
....................    } 
....................     
....................    if (!pEntry.IsValid) 
0856:  BTFSC  x5C.0
0858:  BRA    0860
....................       return FALSE; 
085A:  MOVLW  00
085C:  MOVWF  01
085E:  BRA    08E4
....................  
....................    PartitionLBABegin = MAKE32(SectorBuffer[startingPos + 11], SectorBuffer[startingPos + 10], SectorBuffer[startingPos + 9], SectorBuffer[startingPos + 8]); 
0860:  MOVLW  0B
0862:  ADDWF  xA3,W
0864:  MOVWF  xA5
0866:  MOVLW  00
0868:  ADDWFC xA4,W
086A:  MOVWF  xA6
086C:  MOVLW  05
086E:  ADDWF  xA5,W
0870:  MOVWF  FE9
0872:  MOVLW  00
0874:  ADDWFC xA6,W
0876:  MOVWF  FEA
0878:  MOVFF  FEF,2A7
087C:  MOVLW  0A
087E:  ADDWF  xA3,W
0880:  MOVWF  xA8
0882:  MOVLW  00
0884:  ADDWFC xA4,W
0886:  MOVWF  xA9
0888:  MOVLW  05
088A:  ADDWF  xA8,W
088C:  MOVWF  FE9
088E:  MOVLW  00
0890:  ADDWFC xA9,W
0892:  MOVWF  FEA
0894:  MOVFF  FEF,2AA
0898:  MOVLW  09
089A:  ADDWF  xA3,W
089C:  MOVWF  xAB
089E:  MOVLW  00
08A0:  ADDWFC xA4,W
08A2:  MOVWF  xAC
08A4:  MOVLW  05
08A6:  ADDWF  xAB,W
08A8:  MOVWF  FE9
08AA:  MOVLW  00
08AC:  ADDWFC xAC,W
08AE:  MOVWF  FEA
08B0:  MOVFF  FEF,2AD
08B4:  MOVLW  08
08B6:  ADDWF  xA3,W
08B8:  MOVWF  xAE
08BA:  MOVLW  00
08BC:  ADDWFC xA4,W
08BE:  MOVWF  xAF
08C0:  MOVLW  05
08C2:  ADDWF  xAE,W
08C4:  MOVWF  FE9
08C6:  MOVLW  00
08C8:  ADDWFC xAF,W
08CA:  MOVWF  FEA
08CC:  MOVFF  FEF,2B0
08D0:  MOVFF  2A7,236
08D4:  MOVFF  2AA,235
08D8:  MOVFF  2AD,234
08DC:  MOVFF  2B0,233
....................     
....................    return TRUE; 
08E0:  MOVLW  01
08E2:  MOVWF  01
.................... } 
08E4:  MOVLB  0
08E6:  GOTO   0936 (RETURN)
....................  
.................... BOOLEAN FindFirstFATPartition() 
.................... { 
....................    BYTE i; 
....................  
....................    // Read the first Sector 
....................    ReadSector(0); 
08EA:  MOVLB  3
08EC:  CLRF   x01
08EE:  CLRF   x00
08F0:  MOVLB  2
08F2:  CLRF   xFF
08F4:  CLRF   xFE
08F6:  MOVLB  0
08F8:  RCALL  07AE
....................  
....................    if (SectorBuffer[0x1FE] != 0x55 || SectorBuffer[0x1FF] != 0xAA) return FALSE;    //If no correct signature, return  
08FA:  MOVLB  2
08FC:  MOVF   x03,W
08FE:  SUBLW  55
0900:  BNZ   0908
0902:  MOVF   x04,W
0904:  SUBLW  AA
0906:  BZ    090E
0908:  MOVLW  00
090A:  MOVWF  01
090C:  BRA    095A
....................     
....................    pEntry.IsValid = FALSE; 
090E:  BCF    x5C.0
....................    for (i = 0; i < 4; i++) 
0910:  CLRF   xA0
0912:  MOVF   xA0,W
0914:  SUBLW  03
0916:  BNC   0946
....................    { 
....................       if (GetEntry(FIRST_PARTITION_ENTRY + (i * PARTITION_ENTRY_SIZE))) 
0918:  MOVF   xA0,W
091A:  MULLW  10
091C:  MOVF   FF3,W
091E:  ADDLW  BE
0920:  MOVWF  xA1
0922:  MOVLW  01
0924:  MOVWF  xA2
0926:  BTFSC  FD8.0
0928:  INCF   xA2,F
092A:  MOVFF  2A2,2A4
092E:  MOVFF  2A1,2A3
0932:  MOVLB  0
0934:  BRA    07F8
0936:  MOVF   01,F
0938:  BZ    0940
....................          break; 
093A:  MOVLB  2
093C:  BRA    0946
093E:  MOVLB  0
....................    } 
0940:  MOVLB  2
0942:  INCF   xA0,F
0944:  BRA    0912
....................     
....................    //Worst case. No partitions entry. Asume that MBR is at Sector 0 and its a FAT32 image. 
....................    if (!pEntry.IsValid) 
0946:  BTFSC  x5C.0
0948:  BRA    0956
....................    { 
....................       // Look for the offset 
....................       PartitionLBABegin = 0; 
094A:  CLRF   x36
094C:  CLRF   x35
094E:  CLRF   x34
0950:  CLRF   x33
....................       pEntry.IsFAT32 = TRUE; 
0952:  BSF    x5C.1
....................       pEntry.IsValid = TRUE; 
0954:  BSF    x5C.0
....................    } 
....................  
....................    return TRUE; 
0956:  MOVLW  01
0958:  MOVWF  01
.................... } 
095A:  MOVLB  0
095C:  GOTO   16EA (RETURN)
....................  
.................... BOOLEAN ReadVolumeID() 
.................... {         
....................    // Read the first sector of the partition 
....................    ReadSector(PartitionLBABegin); 
*
0AFE:  MOVFF  236,301
0B02:  MOVFF  235,300
0B06:  MOVFF  234,2FF
0B0A:  MOVFF  233,2FE
0B0E:  RCALL  07AE
....................  
....................    //Initial values 
....................    FAT16Offset = 0; 
0B10:  MOVLB  2
0B12:  CLRF   x3F
....................  
....................    // If the signature is 0xAA55 we are in presence of a FAT volume 
....................    if (SectorBuffer[0x1FE] != 0x55 || SectorBuffer[0x1FF] != 0xAA) return FALSE;    //If no correct signature, return  
0B14:  MOVF   x03,W
0B16:  SUBLW  55
0B18:  BNZ   0B20
0B1A:  MOVF   x04,W
0B1C:  SUBLW  AA
0B1E:  BZ    0B26
0B20:  MOVLW  00
0B22:  MOVWF  01
0B24:  BRA    0C60
....................         
....................    // Bytes per Sector 
....................    BytesPerSector = MAKE16(SectorBuffer[0x0B + 1],SectorBuffer[0x0B]); 
0B26:  MOVFF  11,226
0B2A:  MOVFF  10,225
....................  
....................    // Sectors per Cluster 
....................    SectorsPerCluster = SectorBuffer[0x0D]; 
0B2E:  MOVFF  12,227
....................  
....................    // Number of Reserved Sectors 
....................    NumberOfReservedSectors = Make16(SectorBuffer[0x0E + 1],SectorBuffer[0x0E]); 
0B32:  MOVFF  14,229
0B36:  MOVFF  13,228
....................  
....................    // Number of FATs 
....................    NumberOfFATs = SectorBuffer[0x10]; 
0B3A:  MOVFF  15,22A
....................  
....................    // Sectors per FAT    //differents in FAT16/32 
....................    if (pEntry.IsFAT32) 
0B3E:  BTFSS  x5C.1
0B40:  BRA    0B54
....................    { 
....................       SectorsPerFAT = MAKE32(SectorBuffer[0x24+3], SectorBuffer[0x24 + 2], SectorBuffer[0x24 + 1], SectorBuffer[0x24]); 
0B42:  MOVFF  2C,22E
0B46:  MOVFF  2B,22D
0B4A:  MOVFF  2A,22C
0B4E:  MOVFF  29,22B
....................    } else { 
0B52:  BRA    0BE6
....................       SectorsPerFAT = MAKE16(SectorBuffer[0x16 + 1], SectorBuffer[0x16]); 
0B54:  MOVFF  1C,22C
0B58:  MOVFF  1B,22B
0B5C:  CLRF   x2D
0B5E:  CLRF   x2E
....................       // FAT16 have an offset to calculate real ClusterBeginLBA 
....................       FAT16Offset = ((unsigned int32)MAKE16(SectorBuffer[0x11 + 1], SectorBuffer[0x11]) * 32) / ((unsigned int32)BytesPerSector); 
0B60:  MOVFF  17,2A1
0B64:  MOVFF  16,2A0
0B68:  CLRF   xA2
0B6A:  CLRF   xA3
0B6C:  RLCF   16,W
0B6E:  MOVWF  xA4
0B70:  RLCF   17,W
0B72:  MOVWF  xA5
0B74:  RLCF   xA2,W
0B76:  MOVWF  xA6
0B78:  RLCF   xA3,W
0B7A:  MOVWF  xA7
0B7C:  RLCF   xA4,F
0B7E:  RLCF   xA5,F
0B80:  RLCF   xA6,F
0B82:  RLCF   xA7,F
0B84:  RLCF   xA4,F
0B86:  RLCF   xA5,F
0B88:  RLCF   xA6,F
0B8A:  RLCF   xA7,F
0B8C:  RLCF   xA4,F
0B8E:  RLCF   xA5,F
0B90:  RLCF   xA6,F
0B92:  RLCF   xA7,F
0B94:  RLCF   xA4,F
0B96:  RLCF   xA5,F
0B98:  RLCF   xA6,F
0B9A:  RLCF   xA7,F
0B9C:  MOVLW  E0
0B9E:  ANDWF  xA4,F
0BA0:  MOVFF  225,00
0BA4:  MOVFF  226,01
0BA8:  CLRF   02
0BAA:  CLRF   03
0BAC:  MOVFF  03,2AB
0BB0:  MOVFF  02,2AA
0BB4:  MOVFF  226,2A9
0BB8:  MOVFF  225,2A8
0BBC:  MOVFF  2A7,309
0BC0:  MOVFF  2A6,308
0BC4:  MOVFF  2A5,307
0BC8:  MOVFF  2A4,306
0BCC:  MOVFF  03,30D
0BD0:  MOVFF  02,30C
0BD4:  MOVFF  226,30B
0BD8:  MOVFF  225,30A
0BDC:  MOVLB  0
0BDE:  RCALL  0960
0BE0:  MOVFF  00,23F
0BE4:  MOVLB  2
....................    } 
....................  
....................    // Important zones CALCULUS: 
....................    FatBeginLBA = PartitionLBABegin + ((unsigned int32)NumberOfReservedSectors); 
0BE6:  CLRF   02
0BE8:  CLRF   03
0BEA:  MOVF   x28,W
0BEC:  ADDWF  x33,W
0BEE:  MOVWF  x37
0BF0:  MOVF   x29,W
0BF2:  ADDWFC x34,W
0BF4:  MOVWF  x38
0BF6:  MOVF   02,W
0BF8:  ADDWFC x35,W
0BFA:  MOVWF  x39
0BFC:  MOVF   03,W
0BFE:  ADDWFC x36,W
0C00:  MOVWF  x3A
....................    DataBeginLBA = FatBeginLBA + ((unsigned int32)(NumberOfFATs * SectorsPerFAT)); 
0C02:  MOVLB  3
0C04:  CLRF   x09
0C06:  CLRF   x08
0C08:  CLRF   x07
0C0A:  MOVFF  22A,306
0C0E:  MOVFF  22E,30D
0C12:  MOVFF  22D,30C
0C16:  MOVFF  22C,30B
0C1A:  MOVFF  22B,30A
0C1E:  MOVLB  0
0C20:  RCALL  0AA2
0C22:  MOVF   00,W
0C24:  MOVLB  2
0C26:  ADDWF  x37,W
0C28:  MOVWF  x3B
0C2A:  MOVF   01,W
0C2C:  ADDWFC x38,W
0C2E:  MOVWF  x3C
0C30:  MOVF   02,W
0C32:  ADDWFC x39,W
0C34:  MOVWF  x3D
0C36:  MOVF   03,W
0C38:  ADDWFC x3A,W
0C3A:  MOVWF  x3E
....................  
....................    // Root Directory First Cluster 
....................    if (pEntry.IsFAT32) 
0C3C:  BTFSS  x5C.1
0C3E:  BRA    0C52
....................    { 
....................       RootDirectoryFirstCluster = MAKE32(SectorBuffer[0x2C + 3], SectorBuffer[0x2C + 2], SectorBuffer[0x2C + 1], SectorBuffer[0x2C]);   
0C40:  MOVFF  34,232
0C44:  MOVFF  33,231
0C48:  MOVFF  32,230
0C4C:  MOVFF  31,22F
....................    } else { 
0C50:  BRA    0C5C
....................       //DataBeginLBA += 32; 
....................       RootDirectoryFirstCluster = 2; 
0C52:  CLRF   x32
0C54:  CLRF   x31
0C56:  CLRF   x30
0C58:  MOVLW  02
0C5A:  MOVWF  x2F
....................    } 
....................     
....................    return TRUE; 
0C5C:  MOVLW  01
0C5E:  MOVWF  01
.................... } 
0C60:  MOVLB  0
0C62:  GOTO   17B2 (RETURN)
....................  
.................... unsigned int32 ComputeLBA(unsigned int32 clusternumber) 
.................... { 
....................    // Compute the LBA number using the Cluster Number{ 
....................    return DataBeginLBA + ((clusternumber - 2) * ((unsigned int32)SectorsPerCluster)); 
*
0DD2:  MOVLW  02
0DD4:  MOVLB  2
0DD6:  SUBWF  xEA,W
0DD8:  MOVWF  xEE
0DDA:  MOVLW  00
0DDC:  SUBWFB xEB,W
0DDE:  MOVWF  xEF
0DE0:  MOVLW  00
0DE2:  SUBWFB xEC,W
0DE4:  MOVWF  xF0
0DE6:  MOVLW  00
0DE8:  SUBWFB xED,W
0DEA:  MOVWF  xF1
0DEC:  MOVFF  227,00
0DF0:  CLRF   01
0DF2:  CLRF   02
0DF4:  CLRF   03
0DF6:  MOVFF  03,2F5
0DFA:  MOVFF  02,2F4
0DFE:  MOVFF  01,2F3
0E02:  MOVFF  227,2F2
0E06:  MOVFF  FE8,309
0E0A:  MOVFF  2F0,308
0E0E:  MOVFF  2EF,307
0E12:  MOVFF  2EE,306
0E16:  MOVFF  03,30D
0E1A:  MOVFF  02,30C
0E1E:  MOVFF  01,30B
0E22:  MOVFF  227,30A
0E26:  MOVLB  0
0E28:  RCALL  0AA2
0E2A:  MOVLB  2
0E2C:  MOVF   x3B,W
0E2E:  ADDWF  00,F
0E30:  MOVF   x3C,W
0E32:  ADDWFC 01,F
0E34:  MOVF   x3D,W
0E36:  ADDWFC 02,F
0E38:  MOVF   x3E,W
0E3A:  ADDWFC 03,F
.................... } 
0E3C:  MOVLB  0
0E3E:  RETLW  00
....................  
.................... BOOLEAN CheckIfEOD() 
.................... { 
....................    // Check if the current directory entry (contained in the DirEntry vector) 
....................    // correspond to the flag End Of Directory. 
....................    if (DirEntry[0] == 0x00) 
*
0EF4:  MOVLB  2
0EF6:  MOVF   x05,F
0EF8:  BNZ   0F02
....................    { 
....................        return TRUE; 
0EFA:  MOVLW  01
0EFC:  MOVWF  01
0EFE:  BRA    0F08
....................    } 
....................    else 
0F00:  BRA    0F08
....................    { 
....................        return FALSE; 
0F02:  MOVLW  00
0F04:  MOVWF  01
0F06:  BRA    0F08
....................    } 
.................... } 
0F08:  MOVLB  0
0F0A:  RETLW  00
....................  
.................... BYTE GetAttib() 
.................... { 
....................    // Get the Attributes byte from current Directory Entry 
....................    return DirEntry[0x0B]; 
0F0C:  MOVLB  2
0F0E:  MOVFF  210,01
.................... } 
0F12:  MOVLB  0
0F14:  RETLW  00
....................  
.................... BOOLEAN CheckIfNormalFile() 
.................... { 
....................    // Check if the Directory Entry corresponds to a Normal File Name 
....................    BYTE attr; 
....................     
....................    attr = GetAttib(); 
0F16:  RCALL  0F0C
0F18:  MOVFF  01,2C0
....................  
....................    attr <<= 4; 
0F1C:  MOVLB  2
0F1E:  SWAPF  xC0,F
0F20:  MOVLW  F0
0F22:  ANDWF  xC0,F
....................    if (attr == 0xF0) 
0F24:  MOVF   xC0,W
0F26:  SUBLW  F0
0F28:  BNZ   0F32
....................    { 
....................        // If not, it is a Long File Name entry 
....................        return FALSE; 
0F2A:  MOVLW  00
0F2C:  MOVWF  01
0F2E:  BRA    0F38
....................    } 
....................    else 
0F30:  BRA    0F38
....................    { 
....................        return TRUE; 
0F32:  MOVLW  01
0F34:  MOVWF  01
0F36:  BRA    0F38
....................    } 
.................... } 
0F38:  MOVLB  0
0F3A:  GOTO   0F66 (RETURN)
....................  
.................... BYTE DetermineDirEntryType() 
.................... { 
....................    // Determine the Directory Entry type 
....................    if (CheckIfEOD()) 
0F3E:  RCALL  0EF4
0F40:  MOVF   01,F
0F42:  BZ    0F52
....................    { 
....................        // The Directory Entry is an End Of Directory flag 
....................        EODReached = TRUE; 
0F44:  MOVLB  2
0F46:  BSF    x4B.1
....................        return EOD; 
0F48:  MOVLW  00
0F4A:  MOVWF  01
0F4C:  BRA    0F8E
....................    } 
....................    else 
0F4E:  BRA    0F8E
0F50:  MOVLB  0
....................    { 
....................        // If not, we check the first byte to know if the entry is unused 
....................        if (DirEntry[0] == 0xE5) 
0F52:  MOVLB  2
0F54:  MOVF   x05,W
0F56:  SUBLW  E5
0F58:  BNZ   0F62
....................        { 
....................            return UNUSED; 
0F5A:  MOVLW  01
0F5C:  MOVWF  01
0F5E:  BRA    0F8E
....................        } 
....................        else 
0F60:  BRA    0F8E
....................        { 
....................            // If it is used, we check if the Directory Entry corresponds to a Normal File Name 
....................            if (CheckIfNormalFile()) 
0F62:  MOVLB  0
0F64:  BRA    0F16
0F66:  MOVF   01,F
0F68:  BZ    0F86
....................            { 
....................                if(bit_test(GetAttib(),4)) return NDNAME;       //is a sub directory. 
0F6A:  RCALL  0F0C
0F6C:  MOVFF  01,2C0
0F70:  MOVLB  2
0F72:  BTFSS  01.4
0F74:  BRA    0F7C
0F76:  MOVLW  04
0F78:  MOVWF  01
0F7A:  BRA    0F8E
....................                return NFNAME; 
0F7C:  MOVLW  03
0F7E:  MOVWF  01
0F80:  BRA    0F8E
....................            } 
....................            else 
0F82:  BRA    0F8E
0F84:  MOVLB  0
....................            { 
....................                return LFNAME; 
0F86:  MOVLW  02
0F88:  MOVWF  01
0F8A:  MOVLB  2
0F8C:  BRA    0F8E
....................            } 
....................        } 
....................    } 
.................... } 
0F8E:  MOVLB  0
0F90:  GOTO   12C8 (RETURN)
....................  
.................... unsigned int32 GetFileSize() 
.................... { 
....................    // Get the file size of the current Directory Entry 
....................    return MAKE32(DirEntry[0x1C + 3], DirEntry[0x1C + 2], DirEntry[0x1C + 1], DirEntry[0x1C + 0]); 
*
1088:  MOVFF  224,03
108C:  MOVFF  223,02
1090:  MOVFF  222,01
1094:  MOVFF  221,00
.................... } 
1098:  GOTO   1344 (RETURN)
....................  
.................... void GetFileName(BYTE * filename) 
.................... { 
....................    // Get the 8+3 FAT32 short file name. 
....................    // This function may be changed in other platforms and/or architectures 
....................    // using the correct string functions. 
....................    unsigned int8 i; 
....................     
....................    for (i = 0; i < 8; i++) 
*
0FF8:  MOVLB  2
0FFA:  CLRF   xC2
0FFC:  MOVF   xC2,W
0FFE:  SUBLW  07
1000:  BNC   1034
....................    { 
....................        filename[i] = DirEntry[i]; 
1002:  CLRF   03
1004:  MOVF   xC2,W
1006:  ADDWF  xC0,W
1008:  MOVWF  01
100A:  MOVF   xC1,W
100C:  ADDWFC 03,F
100E:  MOVFF  03,2C4
1012:  CLRF   03
1014:  MOVF   xC2,W
1016:  ADDLW  05
1018:  MOVWF  FE9
101A:  MOVLW  02
101C:  ADDWFC 03,W
101E:  MOVWF  FEA
1020:  MOVFF  FEF,2C5
1024:  MOVFF  2C4,FEA
1028:  MOVFF  01,FE9
102C:  MOVFF  2C5,FEF
....................    } 
1030:  INCF   xC2,F
1032:  BRA    0FFC
....................    filename[8] = '.'; 
1034:  MOVLW  08
1036:  ADDWF  xC0,W
1038:  MOVWF  FE9
103A:  MOVLW  00
103C:  ADDWFC xC1,W
103E:  MOVWF  FEA
1040:  MOVLW  2E
1042:  MOVWF  FEF
....................    for (i = 8; i < 11; i++) 
1044:  MOVLW  08
1046:  MOVWF  xC2
1048:  MOVF   xC2,W
104A:  SUBLW  0A
104C:  BNC   1082
....................    { 
....................        filename[i + 1] = DirEntry[i]; 
104E:  MOVLW  01
1050:  ADDWF  xC2,W
1052:  CLRF   03
1054:  ADDWF  xC0,W
1056:  MOVWF  01
1058:  MOVF   xC1,W
105A:  ADDWFC 03,F
105C:  MOVFF  03,2C5
1060:  CLRF   03
1062:  MOVF   xC2,W
1064:  ADDLW  05
1066:  MOVWF  FE9
1068:  MOVLW  02
106A:  ADDWFC 03,W
106C:  MOVWF  FEA
106E:  MOVFF  FEF,2C6
1072:  MOVFF  2C5,FEA
1076:  MOVFF  01,FE9
107A:  MOVFF  2C6,FEF
....................    } 
107E:  INCF   xC2,F
1080:  BRA    1048
....................     
.................... } 
1082:  MOVLB  0
1084:  GOTO   1342 (RETURN)
....................  
.................... void GetDirName(BYTE * filename) 
.................... { 
....................    // Get the 8 FAT32 short file name. 
....................    // This function may be changed in other platforms and/or architectures 
....................    // using the correct string functions. 
....................    unsigned int8 i; 
....................     
....................    for (i = 0; i < 11; i++) 
*
0F94:  MOVLB  2
0F96:  CLRF   xC2
0F98:  MOVF   xC2,W
0F9A:  SUBLW  0A
0F9C:  BNC   0FD0
....................    { 
....................        filename[i] = DirEntry[i]; 
0F9E:  CLRF   03
0FA0:  MOVF   xC2,W
0FA2:  ADDWF  xC0,W
0FA4:  MOVWF  01
0FA6:  MOVF   xC1,W
0FA8:  ADDWFC 03,F
0FAA:  MOVFF  03,2C4
0FAE:  CLRF   03
0FB0:  MOVF   xC2,W
0FB2:  ADDLW  05
0FB4:  MOVWF  FE9
0FB6:  MOVLW  02
0FB8:  ADDWFC 03,W
0FBA:  MOVWF  FEA
0FBC:  MOVFF  FEF,2C5
0FC0:  MOVFF  2C4,FEA
0FC4:  MOVFF  01,FE9
0FC8:  MOVFF  2C5,FEF
....................    } 
0FCC:  INCF   xC2,F
0FCE:  BRA    0F98
....................  
....................    filename[i]='\0'; 
0FD0:  CLRF   03
0FD2:  MOVF   xC2,W
0FD4:  ADDWF  xC0,W
0FD6:  MOVWF  FE9
0FD8:  MOVF   xC1,W
0FDA:  ADDWFC 03,W
0FDC:  MOVWF  FEA
0FDE:  CLRF   FEF
....................  
.................... } 
0FE0:  MOVLB  0
0FE2:  GOTO   12E2 (RETURN)
....................  
.................... unsigned int32 GetFileFirstCluster() 
.................... { 
....................    // Get the file first cluster using the current Directory Entry data 
....................    return MAKE32(DirEntry[0x14 + 1], DirEntry[0x14], DirEntry[0x1A + 1], DirEntry[0x1A]); 
0FE6:  MOVFF  21A,03
0FEA:  MOVFF  219,02
0FEE:  MOVFF  220,01
0FF2:  MOVFF  21F,00
.................... } 
0FF6:  RETLW  00
....................  
.................... unsigned int32 ReadFAT(unsigned int32 clusternumber) 
.................... { 
....................    // This might be one of the most complicated functions in the entire FAT16/32 
....................    // implementation. It computes the next cluster of a file/directory reading the 
....................    // FAT table. 
....................  
....................    // Calculate the sector number (after FAT LBA Begin) in which we can find 
....................    // the cluster information we are looking for. 
....................     
....................    unsigned int32 calc; 
....................    unsigned int32 offset; 
....................    unsigned int32 rest; 
....................    unsigned int32 soff; 
....................     
....................    calc = clusternumber / ((unsigned int32)BytesPerSector / 4); 
*
109C:  MOVLB  3
109E:  CLRF   x01
10A0:  CLRF   x00
10A2:  MOVFF  226,2FF
10A6:  MOVFF  225,2FE
10AA:  RRCF   x01,W
10AC:  MOVWF  03
10AE:  RRCF   x00,W
10B0:  MOVWF  02
10B2:  MOVLB  2
10B4:  RRCF   x26,W
10B6:  MOVWF  01
10B8:  RRCF   x25,W
10BA:  MOVWF  00
10BC:  RRCF   03,F
10BE:  RRCF   02,F
10C0:  RRCF   01,F
10C2:  RRCF   00,F
10C4:  MOVLW  3F
10C6:  ANDWF  03,F
10C8:  MOVFF  03,305
10CC:  MOVFF  02,304
10D0:  MOVFF  01,303
10D4:  MOVFF  00,302
10D8:  MOVFF  2ED,309
10DC:  MOVFF  2EC,308
10E0:  MOVFF  2EB,307
10E4:  MOVFF  2EA,306
10E8:  MOVFF  03,30D
10EC:  MOVFF  02,30C
10F0:  MOVFF  01,30B
10F4:  MOVFF  00,30A
10F8:  MOVLB  0
10FA:  RCALL  0960
10FC:  MOVFF  03,2F1
1100:  MOVFF  02,2F0
1104:  MOVFF  01,2EF
1108:  MOVFF  00,2EE
....................  
....................    // Calculate the LBA of the sector containing the information 
....................    offset = FatBeginLBA + calc; 
110C:  MOVLB  2
110E:  MOVF   xEE,W
1110:  ADDWF  x37,W
1112:  MOVWF  xF2
1114:  MOVF   xEF,W
1116:  ADDWFC x38,W
1118:  MOVWF  xF3
111A:  MOVF   xF0,W
111C:  ADDWFC x39,W
111E:  MOVWF  xF4
1120:  MOVF   xF1,W
1122:  ADDWFC x3A,W
1124:  MOVWF  xF5
....................  
....................    // Calculate the offset within the sector that has been read 
....................    rest = clusternumber - (calc * ((unsigned int32)BytesPerSector / 4)); 
1126:  MOVLB  3
1128:  CLRF   x01
112A:  CLRF   x00
112C:  MOVFF  226,2FF
1130:  MOVFF  225,2FE
1134:  RRCF   x01,W
1136:  MOVWF  03
1138:  RRCF   x00,W
113A:  MOVWF  02
113C:  MOVLB  2
113E:  RRCF   x26,W
1140:  MOVWF  01
1142:  RRCF   x25,W
1144:  MOVWF  00
1146:  RRCF   03,F
1148:  RRCF   02,F
114A:  RRCF   01,F
114C:  RRCF   00,F
114E:  MOVLW  3F
1150:  ANDWF  03,F
1152:  MOVFF  03,305
1156:  MOVFF  02,304
115A:  MOVFF  01,303
115E:  MOVFF  00,302
1162:  MOVFF  2F1,309
1166:  MOVFF  2F0,308
116A:  MOVFF  2EF,307
116E:  MOVFF  2EE,306
1172:  MOVFF  03,30D
1176:  MOVFF  02,30C
117A:  MOVFF  01,30B
117E:  MOVFF  00,30A
1182:  MOVLB  0
1184:  RCALL  0AA2
1186:  MOVF   00,W
1188:  MOVLB  2
118A:  SUBWF  xEA,W
118C:  MOVWF  xF6
118E:  MOVF   01,W
1190:  SUBWFB xEB,W
1192:  MOVWF  xF7
1194:  MOVF   02,W
1196:  SUBWFB xEC,W
1198:  MOVWF  xF8
119A:  MOVF   03,W
119C:  SUBWFB xED,W
119E:  MOVWF  xF9
....................    soff = rest * 4; 
11A0:  RLCF   xF6,W
11A2:  MOVWF  xFA
11A4:  RLCF   xF7,W
11A6:  MOVWF  xFB
11A8:  RLCF   xF8,W
11AA:  MOVWF  xFC
11AC:  RLCF   xF9,W
11AE:  MOVWF  xFD
11B0:  RLCF   xFA,F
11B2:  RLCF   xFB,F
11B4:  RLCF   xFC,F
11B6:  RLCF   xFD,F
11B8:  MOVLW  FC
11BA:  ANDWF  xFA,F
....................  
....................    // Read the sector 
....................    ReadSector(offset); 
11BC:  MOVFF  2F5,301
11C0:  MOVFF  2F4,300
11C4:  MOVFF  2F3,2FF
11C8:  MOVFF  2F2,2FE
11CC:  MOVLB  0
11CE:  CALL   07AE
....................    // Read the next cluster number 
....................    return MAKE32(SectorBuffer[soff + 3], SectorBuffer[soff + 2], SectorBuffer[soff + 1], SectorBuffer[soff]); 
11D2:  MOVLW  03
11D4:  MOVLB  2
11D6:  ADDWF  xFA,W
11D8:  MOVWF  xFE
11DA:  MOVLW  00
11DC:  ADDWFC xFB,W
11DE:  MOVWF  xFF
11E0:  MOVLW  00
11E2:  ADDWFC xFC,W
11E4:  MOVLW  00
11E6:  MOVLB  2
11E8:  ADDWFC xFD,W
11EA:  MOVLW  05
11EC:  MOVLB  2
11EE:  ADDWF  xFE,W
11F0:  MOVWF  FE9
11F2:  MOVLW  00
11F4:  ADDWFC xFF,W
11F6:  MOVWF  FEA
11F8:  MOVFF  FEF,302
11FC:  MOVLW  02
11FE:  ADDWF  xFA,W
1200:  MOVLB  3
1202:  MOVWF  x03
1204:  MOVLW  00
1206:  MOVLB  2
1208:  ADDWFC xFB,W
120A:  MOVLB  3
120C:  MOVWF  x04
120E:  MOVLW  00
1210:  MOVLB  2
1212:  ADDWFC xFC,W
1214:  MOVLW  00
1216:  MOVLB  2
1218:  ADDWFC xFD,W
121A:  MOVLB  3
121C:  MOVLW  05
121E:  ADDWF  x03,W
1220:  MOVWF  FE9
1222:  MOVLW  00
1224:  ADDWFC x04,W
1226:  MOVWF  FEA
1228:  MOVFF  FEF,307
122C:  MOVLW  01
122E:  MOVLB  2
1230:  ADDWF  xFA,W
1232:  MOVLB  3
1234:  MOVWF  x08
1236:  MOVLW  00
1238:  MOVLB  2
123A:  ADDWFC xFB,W
123C:  MOVLB  3
123E:  MOVWF  x09
1240:  MOVLW  00
1242:  MOVLB  2
1244:  ADDWFC xFC,W
1246:  MOVLW  00
1248:  MOVLB  2
124A:  ADDWFC xFD,W
124C:  MOVLB  3
124E:  MOVLW  05
1250:  ADDWF  x08,W
1252:  MOVWF  FE9
1254:  MOVLW  00
1256:  ADDWFC x09,W
1258:  MOVWF  FEA
125A:  MOVFF  FEF,30C
125E:  MOVLW  05
1260:  MOVLB  2
1262:  ADDWF  xFA,W
1264:  MOVWF  FE9
1266:  MOVLW  00
1268:  ADDWFC xFB,W
126A:  MOVWF  FEA
126C:  MOVFF  FEF,30D
1270:  MOVFF  302,03
1274:  MOVFF  307,02
1278:  MOVFF  30C,01
127C:  MOVFF  30D,00
.................... } 
1280:  MOVLB  0
1282:  RETLW  00
....................  
.................... void OpenDirectory(unsigned int32 directorycluster) 
.................... { 
....................    // Initialize the variables needed to follow the directory pointed by 
....................    // the passed argument. 
....................    DirectoryCurrentCluster = directorycluster; 
*
0E40:  MOVFF  2A3,243
0E44:  MOVFF  2A2,242
0E48:  MOVFF  2A1,241
0E4C:  MOVFF  2A0,240
....................    DirectoryCurrentLBA = ComputeLBA(DirectoryCurrentCluster); 
0E50:  MOVFF  243,2ED
0E54:  MOVFF  242,2EC
0E58:  MOVFF  241,2EB
0E5C:  MOVFF  240,2EA
0E60:  RCALL  0DD2
0E62:  MOVFF  03,247
0E66:  MOVFF  02,246
0E6A:  MOVFF  01,245
0E6E:  MOVFF  00,244
....................    DirectoryCurrentDirEntry = 0; 
0E72:  MOVLB  2
0E74:  CLRF   x48
....................    DirectoryCurrentSector = 0; 
0E76:  CLRF   x4A
0E78:  CLRF   x49
....................  
....................    EODReached = FALSE; 
0E7A:  BCF    x4B.1
....................    DirectoryOpened = TRUE; 
0E7C:  BSF    x4B.0
.................... } 
0E7E:  MOVLB  0
0E80:  GOTO   1AEC (RETURN)
....................  
.................... FILEDESCRIPTOR FindNextFile() 
.................... { 
....................    // Define the variables that will be used 
....................    FILEDESCRIPTOR thefile; 
....................    BOOLEAN filefound; 
....................  
....................    // Set initial values 
....................    filefound = FALSE; 
*
1284:  MOVLB  2
1286:  BCF    xBF.0
....................     
....................    thefile.Attributes = 0; 
1288:  CLRF   xB2
....................    thefile.FirstLBA = 0; 
128A:  CLRF   xB6
128C:  CLRF   xB5
128E:  CLRF   xB4
1290:  CLRF   xB3
....................    thefile.FirstCluster = 0; 
1292:  CLRF   xBE
1294:  CLRF   xBD
1296:  CLRF   xBC
1298:  CLRF   xBB
....................    thefile.Size = 0; 
129A:  CLRF   xBA
129C:  CLRF   xB9
129E:  CLRF   xB8
12A0:  CLRF   xB7
....................  
....................    // Read the next sector of the cluster 
....................    ReadSector(DirectoryCurrentLBA); 
12A2:  MOVFF  247,301
12A6:  MOVFF  246,300
12AA:  MOVFF  245,2FF
12AE:  MOVFF  244,2FE
12B2:  MOVLB  0
12B4:  CALL   07AE
....................  
....................    // If the directory has been opened with OpenDirectory 
....................    if (DirectoryOpened) 
12B8:  MOVLB  2
12BA:  BTFSS  x4B.0
12BC:  BRA    143C
....................    { 
....................        // Follow the Directory Entries looking for files 
....................        do 
....................        { 
....................            // Read the next directory entry 
....................            ReadDirEntry(DirectoryCurrentDirEntry); 
12BE:  MOVFF  248,2C0
12C2:  MOVLB  0
12C4:  BRA    0E84
....................  
....................             switch (DetermineDirEntryType()) 
....................             { 
12C6:  BRA    0F3E
12C8:  MOVF   01,W
12CA:  XORLW  04
12CC:  BZ    12D4
12CE:  XORLW  07
12D0:  BZ    132C
12D2:  BRA    139E
....................                // If the directory entry is a Normal Directory Name 
....................                case NDNAME: 
....................                   // We are in presence of a sub directory, and we get its information 
....................                   GetDirName(thefile.Name); 
12D4:  MOVLW  02
12D6:  MOVLB  2
12D8:  MOVWF  xC1
12DA:  MOVLW  A6
12DC:  MOVWF  xC0
12DE:  MOVLB  0
12E0:  BRA    0F94
....................                   thefile.Attributes = GetAttib(); 
12E2:  RCALL  0F0C
12E4:  MOVFF  01,2B2
....................                   thefile.FirstCluster = GetFileFirstCluster(); 
12E8:  RCALL  0FE6
12EA:  MOVFF  03,2BE
12EE:  MOVFF  02,2BD
12F2:  MOVFF  01,2BC
12F6:  MOVFF  00,2BB
....................                   thefile.FirstLBA = ComputeLBA(thefile.FirstCluster) + FAT16Offset; 
12FA:  MOVFF  2BE,2ED
12FE:  MOVFF  2BD,2EC
1302:  MOVFF  2BC,2EB
1306:  MOVFF  2BB,2EA
130A:  RCALL  0DD2
130C:  MOVLB  2
130E:  MOVF   x3F,W
1310:  ADDWF  00,W
1312:  MOVWF  xB3
1314:  MOVLW  00
1316:  ADDWFC 01,W
1318:  MOVWF  xB4
131A:  MOVLW  00
131C:  ADDWFC 02,W
131E:  MOVWF  xB5
1320:  MOVLW  00
1322:  ADDWFC 03,W
1324:  MOVWF  xB6
....................  
....................                   // Read the last computed sector, to re-fill the SectorBuffer 
....................                   // that could have been overwritten when obtaining file information. 
....................                   //ReadSectorRelativeToPartition(DirectoryCurrentLBA);  ???? 
....................  
....................                   // Set the File Found flag 
....................                   filefound = TRUE; 
1326:  BSF    xBF.0
....................                   break; 
1328:  MOVLB  0
132A:  BRA    139E
....................  
....................                // If the directory entry is a Normal File Name 
....................                case NFNAME: 
....................                   // And the Attribute is 0x20 
....................                   if (GetAttib() == 0x20) 
132C:  RCALL  0F0C
132E:  MOVF   01,W
1330:  SUBLW  20
1332:  BNZ   139C
....................                   { 
....................                      // We are in presence of a file, and we get its information 
....................                      GetFileName(thefile.Name); 
1334:  MOVLW  02
1336:  MOVLB  2
1338:  MOVWF  xC1
133A:  MOVLW  A6
133C:  MOVWF  xC0
133E:  MOVLB  0
1340:  BRA    0FF8
....................                      thefile.Size = GetFileSize(); 
1342:  BRA    1088
1344:  MOVFF  03,2BA
1348:  MOVFF  02,2B9
134C:  MOVFF  01,2B8
1350:  MOVFF  00,2B7
....................                      thefile.Attributes = GetAttib(); 
1354:  RCALL  0F0C
1356:  MOVFF  01,2B2
....................                      thefile.FirstCluster = GetFileFirstCluster(); 
135A:  RCALL  0FE6
135C:  MOVFF  03,2BE
1360:  MOVFF  02,2BD
1364:  MOVFF  01,2BC
1368:  MOVFF  00,2BB
....................                      thefile.FirstLBA = ComputeLBA(thefile.FirstCluster) + FAT16Offset; 
136C:  MOVFF  2BE,2ED
1370:  MOVFF  2BD,2EC
1374:  MOVFF  2BC,2EB
1378:  MOVFF  2BB,2EA
137C:  RCALL  0DD2
137E:  MOVLB  2
1380:  MOVF   x3F,W
1382:  ADDWF  00,W
1384:  MOVWF  xB3
1386:  MOVLW  00
1388:  ADDWFC 01,W
138A:  MOVWF  xB4
138C:  MOVLW  00
138E:  ADDWFC 02,W
1390:  MOVWF  xB5
1392:  MOVLW  00
1394:  ADDWFC 03,W
1396:  MOVWF  xB6
....................                       
....................                      // Read the last computed sector, to re-fill the SectorBuffer 
....................                      // that could have been overwritten when obtaining file information. 
....................                      //ReadSectorRelativeToPartition(DirectoryCurrentLBA);  ????? 
....................                       
....................                      // Set the File Found flag 
....................                      filefound = TRUE; 
1398:  BSF    xBF.0
139A:  MOVLB  0
....................                   }                
....................                   break; 
139C:  BRA    139E
....................             } 
....................           
....................            // Increment the current Directory Entry index 
....................            DirectoryCurrentDirEntry++; 
139E:  MOVLB  2
13A0:  INCF   x48,F
....................            // If the Directory Entry index is greater than 15 (only 16 
....................            // directory entries could be found into a sector) 
....................            if (DirectoryCurrentDirEntry > 15) 
13A2:  MOVF   x48,W
13A4:  SUBLW  0F
13A6:  BC    142E
....................            { 
....................                // Reset the Directory Entry index 
....................                DirectoryCurrentDirEntry = 0; 
13A8:  CLRF   x48
....................  
....................                // Increment the current sector index 
....................                DirectoryCurrentSector++; 
13AA:  INCF   x49,F
13AC:  BTFSC  FD8.2
13AE:  INCF   x4A,F
....................                // If the sector index is minor than the SectorsPerCluster 
....................                if (DirectoryCurrentSector < SectorsPerCluster) 
13B0:  MOVF   x4A,F
13B2:  BNZ   13CC
13B4:  MOVF   x27,W
13B6:  SUBWF  x49,W
13B8:  BC    13CC
....................                { 
....................                    // We move to the next sector 
....................                    DirectoryCurrentLBA++; 
13BA:  MOVLW  01
13BC:  ADDWF  x44,F
13BE:  BTFSC  FD8.0
13C0:  INCF   x45,F
13C2:  BTFSC  FD8.2
13C4:  INCF   x46,F
13C6:  BTFSC  FD8.2
13C8:  INCF   x47,F
....................                } 
....................                // If not, we need to move to another cluster 
....................                else 
13CA:  BRA    1416
....................                { 
....................                    // And we compute the next cluster first sector 
....................                    DirectoryCurrentSector = 0; 
13CC:  CLRF   x4A
13CE:  CLRF   x49
....................                    DirectoryCurrentCluster = ReadFAT(DirectoryCurrentCluster); 
13D0:  MOVFF  243,2ED
13D4:  MOVFF  242,2EC
13D8:  MOVFF  241,2EB
13DC:  MOVFF  240,2EA
13E0:  MOVLB  0
13E2:  RCALL  109C
13E4:  MOVFF  03,243
13E8:  MOVFF  02,242
13EC:  MOVFF  01,241
13F0:  MOVFF  00,240
....................                    DirectoryCurrentLBA = ComputeLBA(DirectoryCurrentCluster); 
13F4:  MOVFF  243,2ED
13F8:  MOVFF  242,2EC
13FC:  MOVFF  241,2EB
1400:  MOVFF  240,2EA
1404:  RCALL  0DD2
1406:  MOVFF  03,247
140A:  MOVFF  02,246
140E:  MOVFF  01,245
1412:  MOVFF  00,244
....................                } 
....................  
....................                // Read the next sector computed before 
....................                ReadSector(DirectoryCurrentLBA); 
1416:  MOVFF  247,301
141A:  MOVFF  246,300
141E:  MOVFF  245,2FF
1422:  MOVFF  244,2FE
1426:  MOVLB  0
1428:  CALL   07AE
142C:  MOVLB  2
....................            } 
....................        } 
....................        // Do this until an EOD is found or the File Found flag is set 
....................        while ((!CheckIfEOD()) && (!filefound)); 
142E:  MOVLB  0
1430:  RCALL  0EF4
1432:  MOVF   01,F
1434:  BNZ   143E
1436:  MOVLB  2
1438:  BTFSS  xBF.0
143A:  BRA    12BE
143C:  MOVLB  0
....................    } 
....................  
....................    // Return the File Descriptor 
....................    return thefile; 
143E:  MOVLW  A6
1440:  MOVWF  01
1442:  MOVLW  02
1444:  MOVWF  02
.................... } 
1446:  GOTO   1AF0 (RETURN)
....................  
.................... void CloseDirectory() 
.................... { 
....................    // Close the directory 
....................    DirectoryOpened = FALSE; 
*
16AC:  MOVLB  2
16AE:  BCF    x4B.0
.................... } 
16B0:  MOVLB  0
16B2:  GOTO   1FE4 (RETURN)
....................  
.................... void OpenFile(FILEDESCRIPTOR file) 
.................... { 
....................    // Initialize the variables needed to follow the file pointed by 
....................    // the passed File Descriptor. 
....................    FileCurrentCluster = file.FirstCluster; 
*
144A:  MOVFF  2B8,24F
144E:  MOVFF  2B7,24E
1452:  MOVFF  2B6,24D
1456:  MOVFF  2B5,24C
....................    FileCurrentLBA = ComputeLBA(FileCurrentCluster) + FAT16offset; 
145A:  MOVFF  24F,2ED
145E:  MOVFF  24E,2EC
1462:  MOVFF  24D,2EB
1466:  MOVFF  24C,2EA
146A:  RCALL  0DD2
146C:  MOVLB  2
146E:  MOVF   x3F,W
1470:  ADDWF  00,W
1472:  MOVWF  x50
1474:  MOVLW  00
1476:  ADDWFC 01,W
1478:  MOVWF  x51
147A:  MOVLW  00
147C:  ADDWFC 02,W
147E:  MOVWF  x52
1480:  MOVLW  00
1482:  ADDWFC 03,W
1484:  MOVWF  x53
....................    FileCurrentSector = 0; 
1486:  CLRF   x55
1488:  CLRF   x54
....................    FileLengthCount = 0; 
148A:  CLRF   x59
148C:  CLRF   x58
148E:  CLRF   x57
1490:  CLRF   x56
....................    FileSectorPosition = 0; 
1492:  CLRF   x5B
1494:  CLRF   x5A
....................  
....................    FileOpened = TRUE; 
1496:  BSF    x4B.2
.................... } 
1498:  MOVLB  0
149A:  GOTO   1EA0 (RETURN)
....................  
.................... FILEDATA ReadFile(FILEDESCRIPTOR file, unsigned int32 count) 
.................... { 
....................    // Define the variables that will be used 
....................    FILEDATA data; 
....................    unsigned int16 bytesread = 0; 
149E:  MOVLB  2
14A0:  CLRF   xE6
14A2:  CLRF   xE7
....................    unsigned int16 i; 
....................  
....................    // Set initial values and initialize the Buffer vector 
....................    data.BytesRead = 0; 
14A4:  CLRF   xE4
14A6:  CLRF   xE3
....................    data.EOF = TRUE; 
14A8:  BSF    xE5.0
....................  
....................    // Read the next file sector 
....................    ReadSector(FileCurrentLBA); 
14AA:  MOVFF  253,301
14AE:  MOVFF  252,300
14B2:  MOVFF  251,2FF
14B6:  MOVFF  250,2FE
14BA:  MOVLB  0
14BC:  CALL   07AE
....................  
....................    // If the file has been opened with OpenFile() 
....................    if (FileOpened) 
14C0:  MOVLB  2
14C2:  BTFSS  x4B.2
14C4:  BRA    1648
....................    { 
....................        // Read 'count' bytes from the current file sector 
....................        for (i = 0; i < count; i++) 
14C6:  CLRF   xE9
14C8:  CLRF   xE8
14CA:  MOVF   xC2,F
14CC:  BNZ   14E0
14CE:  MOVF   xC1,F
14D0:  BNZ   14E0
14D2:  MOVF   xE9,W
14D4:  SUBWF  xC0,W
14D6:  BNC   1550
14D8:  BNZ   14E0
14DA:  MOVF   xBF,W
14DC:  SUBWF  xE8,W
14DE:  BC    1550
....................        { 
....................            // Increment the length count 
....................            FileLengthCount++; 
14E0:  MOVLW  01
14E2:  ADDWF  x56,F
14E4:  BTFSC  FD8.0
14E6:  INCF   x57,F
14E8:  BTFSC  FD8.2
14EA:  INCF   x58,F
14EC:  BTFSC  FD8.2
14EE:  INCF   x59,F
....................            // Compare the length count to the total file size 
....................            if (FileLengthCount <= file.Size) 
14F0:  MOVF   x59,W
14F2:  SUBWF  xBA,W
14F4:  BNC   1548
14F6:  BNZ   150E
14F8:  MOVF   x58,W
14FA:  SUBWF  xB9,W
14FC:  BNC   1548
14FE:  BNZ   150E
1500:  MOVF   x57,W
1502:  SUBWF  xB8,W
1504:  BNC   1548
1506:  BNZ   150E
1508:  MOVF   x56,W
150A:  SUBWF  xB7,W
150C:  BNC   1548
....................            { 
....................                // We only read if we have not reached the total file size 
....................                data.Buffer[i] = SectorBuffer[FileSectorPosition + i]; 
150E:  MOVLW  C3
1510:  ADDWF  xE8,W
1512:  MOVWF  01
1514:  MOVLW  02
1516:  ADDWFC xE9,W
1518:  MOVWF  03
151A:  MOVF   xE8,W
151C:  ADDWF  x5A,W
151E:  MOVWF  xEC
1520:  MOVF   xE9,W
1522:  ADDWFC x5B,W
1524:  MOVWF  xED
1526:  MOVLW  05
1528:  ADDWF  xEC,W
152A:  MOVWF  FE9
152C:  MOVLW  00
152E:  ADDWFC xED,W
1530:  MOVWF  FEA
1532:  MOVFF  FEF,2EE
1536:  MOVFF  03,FEA
153A:  MOVFF  01,FE9
153E:  MOVFF  2EE,FEF
....................                // Count the bytes that have been read 
....................                bytesread++; 
1542:  INCF   xE6,F
1544:  BTFSC  FD8.2
1546:  INCF   xE7,F
....................            } 
....................        } 
1548:  INCF   xE8,F
154A:  BTFSC  FD8.2
154C:  INCF   xE9,F
154E:  BRA    14CA
....................         
....................        // Set the bytes read into the resulting FileData structure 
....................        data.BytesRead = bytesread; 
1550:  MOVFF  2E7,2E4
1554:  MOVFF  2E6,2E3
....................  
....................        // Set the current sector position in order to continue from there the next time 
....................        FileSectorPosition += (unsigned int16)bytesread; 
1558:  MOVF   xE6,W
155A:  ADDWF  x5A,F
155C:  MOVF   xE7,W
155E:  ADDWFC x5B,F
....................  
....................        // If the sector position is greater than the maximum sector size 
....................        if (FileSectorPosition > (BUFFER_SIZE - 1)) 
1560:  MOVF   x5B,W
1562:  SUBLW  01
1564:  BC    15FA
....................        { 
....................            // Reset the file sector position 
....................            FileSectorPosition = 0; 
1566:  CLRF   x5B
1568:  CLRF   x5A
....................  
....................            // Increment the current sector 
....................            FileCurrentSector++; 
156A:  INCF   x54,F
156C:  BTFSC  FD8.2
156E:  INCF   x55,F
....................            // If the current sector is minor than the Sectors Per Cluster 
....................            if (FileCurrentSector < SectorsPerCluster) 
1570:  MOVF   x55,F
1572:  BNZ   158C
1574:  MOVF   x27,W
1576:  SUBWF  x54,W
1578:  BC    158C
....................            { 
....................                // Move to the next sector of the cluster 
....................                FileCurrentLBA++; 
157A:  MOVLW  01
157C:  ADDWF  x50,F
157E:  BTFSC  FD8.0
1580:  INCF   x51,F
1582:  BTFSC  FD8.2
1584:  INCF   x52,F
1586:  BTFSC  FD8.2
1588:  INCF   x53,F
....................            } 
....................            // If not, read the FAT looking for the next cluster 
....................            else 
158A:  BRA    15E0
....................            { 
....................                // And then, compute the first cluster sector 
....................                FileCurrentSector = 0; 
158C:  CLRF   x55
158E:  CLRF   x54
....................                FileCurrentCluster = ReadFAT(FileCurrentCluster); 
1590:  MOVFF  24F,2ED
1594:  MOVFF  24E,2EC
1598:  MOVFF  24D,2EB
159C:  MOVFF  24C,2EA
15A0:  MOVLB  0
15A2:  RCALL  109C
15A4:  MOVFF  03,24F
15A8:  MOVFF  02,24E
15AC:  MOVFF  01,24D
15B0:  MOVFF  00,24C
....................                FileCurrentLBA = ComputeLBA(FileCurrentCluster) + FAT16offset; 
15B4:  MOVFF  24F,2ED
15B8:  MOVFF  24E,2EC
15BC:  MOVFF  24D,2EB
15C0:  MOVFF  24C,2EA
15C4:  RCALL  0DD2
15C6:  MOVLB  2
15C8:  MOVF   x3F,W
15CA:  ADDWF  00,W
15CC:  MOVWF  x50
15CE:  MOVLW  00
15D0:  ADDWFC 01,W
15D2:  MOVWF  x51
15D4:  MOVLW  00
15D6:  ADDWFC 02,W
15D8:  MOVWF  x52
15DA:  MOVLW  00
15DC:  ADDWFC 03,W
15DE:  MOVWF  x53
....................            } 
....................            // Read the sector computer before 
....................            ReadSector(FileCurrentLBA); 
15E0:  MOVFF  253,301
15E4:  MOVFF  252,300
15E8:  MOVFF  251,2FF
15EC:  MOVFF  250,2FE
15F0:  MOVLB  0
15F2:  CALL   07AE
....................        } 
....................        // If the sector position is greater than the sector buffer size 
....................        else 
15F6:  BRA    1622
15F8:  MOVLB  2
....................        { 
....................            // Check if the total file size has been reached 
....................            if (FileLengthCount >= file.Size) 
15FA:  MOVF   xBA,W
15FC:  SUBWF  x59,W
15FE:  BNC   1622
1600:  BNZ   1618
1602:  MOVF   xB9,W
1604:  SUBWF  x58,W
1606:  BNC   1622
1608:  BNZ   1618
160A:  MOVF   xB8,W
160C:  SUBWF  x57,W
160E:  BNC   1622
1610:  BNZ   1618
1612:  MOVF   xB7,W
1614:  SUBWF  x56,W
1616:  BNC   1622
....................            { 
....................                // Force an EOF (End of File) 
....................                FileCurrentCluster = 0xFFFFFFFF; 
1618:  MOVLW  FF
161A:  MOVWF  x4F
161C:  MOVWF  x4E
161E:  MOVWF  x4D
1620:  MOVWF  x4C
....................            } 
....................        } 
....................  
....................        // If the current cluster is greater than 0xFFFFFFF8, we have an EOF 
....................        if (FileCurrentCluster < 0xFFFFFFF8) 
1622:  MOVLB  2
1624:  MOVF   x4F,W
1626:  SUBLW  FF
1628:  BNC   1646
162A:  BNZ   1642
162C:  MOVF   x4E,W
162E:  SUBLW  FF
1630:  BNC   1646
1632:  BNZ   1642
1634:  MOVF   x4D,W
1636:  SUBLW  FF
1638:  BNC   1646
163A:  BNZ   1642
163C:  MOVF   x4C,W
163E:  SUBLW  F7
1640:  BNC   1646
....................        { 
....................            data.EOF = FALSE; 
1642:  BCF    xE5.0
....................        } 
....................        else 
1644:  BRA    1648
....................        { 
....................            data.EOF = true; 
1646:  BSF    xE5.0
....................        } 
....................    } 
....................  
....................    // Return the FileData structure 
....................    return data; 
1648:  MOVLW  C3
164A:  MOVWF  01
164C:  MOVLW  02
164E:  MOVWF  02
.................... } 
1650:  MOVLB  0
1652:  GOTO   1F16 (RETURN)
....................  
.................... void CloseFile() 
.................... { 
....................    // Close the currently opened file 
....................    FileOpened = FALSE; 
*
16A2:  MOVLB  2
16A4:  BCF    x4B.2
.................... } 
16A6:  MOVLB  0
16A8:  GOTO   1FBC (RETURN)
....................  
....................  
.................... void main() 
.................... { 
*
16B6:  CLRF   FF8
16B8:  BCF    FD0.7
16BA:  CLRF   FEA
16BC:  CLRF   FE9
16BE:  BCF    F93.7
16C0:  BSF    F8A.7
16C2:  BCF    FC6.5
16C4:  BCF    F94.7
16C6:  BSF    F93.0
16C8:  BCF    F93.1
16CA:  MOVLW  20
16CC:  MOVWF  FC6
16CE:  MOVLW  00
16D0:  MOVWF  FC5
16D2:  MOVF   FC1,W
16D4:  ANDLW  C0
16D6:  IORLW  0F
16D8:  MOVWF  FC1
16DA:  MOVLW  07
16DC:  MOVWF  FB4
....................    unsigned int16 i; 
....................    unsigned int16 j; 
....................    unsigned int16 c; 
....................     
....................    // Create a file descriptor 
....................    FILEDESCRIPTOR fd; 
....................     
....................    // Create a FileData structure 
....................    FILEDATA data; 
....................        
....................    set_tris_a(0x00); 
16DE:  MOVLW  00
16E0:  MOVWF  F92
....................     
....................    mmc_init(); 
16E2:  GOTO   04B6
....................     
....................    // Find the first FAT partition 
....................    FindFirstFATPartition(); 
16E6:  GOTO   08EA
....................     
....................    printf("Partition LBA Begin: %lu\r\n", PartitionLBABegin); 
16EA:  MOVLB  2
16EC:  CLRF   xA0
16EE:  MOVF   xA0,W
16F0:  MOVLB  0
16F2:  CALL   0110
16F6:  MOVLB  2
16F8:  INCF   xA0,F
16FA:  MOVWF  00
16FC:  MOVWF  xB1
16FE:  MOVLB  0
1700:  CALL   0430
1704:  MOVLW  15
1706:  MOVLB  2
1708:  SUBWF  xA0,W
170A:  BNZ   16EE
170C:  MOVLW  41
170E:  MOVWF  FE9
1710:  MOVFF  236,2A8
1714:  MOVFF  235,2A7
1718:  MOVFF  234,2A6
171C:  MOVFF  233,2A5
1720:  MOVLB  0
1722:  CALL   09E0
1726:  MOVLW  0D
1728:  MOVLB  2
172A:  MOVWF  xB1
172C:  MOVLB  0
172E:  CALL   0430
1732:  MOVLW  0A
1734:  MOVLB  2
1736:  MOVWF  xB1
1738:  MOVLB  0
173A:  CALL   0430
....................    if (pEntry.IsValid) 
173E:  MOVLB  2
1740:  BTFSS  x5C.0
1742:  BRA    178C
....................    { 
....................       if (pEntry.IsFAT32) 
1744:  BTFSS  x5C.1
1746:  BRA    176A
....................          printf("System is: FAT32\r\n"); 
1748:  CLRF   xA0
174A:  MOVF   xA0,W
174C:  MOVLB  0
174E:  CALL   013C
1752:  MOVLB  2
1754:  INCF   xA0,F
1756:  MOVWF  00
1758:  MOVWF  xB1
175A:  MOVLB  0
175C:  CALL   0430
1760:  MOVLW  12
1762:  MOVLB  2
1764:  SUBWF  xA0,W
1766:  BNZ   174A
....................       else 
1768:  BRA    178A
....................          printf("System is: FAT16\r\n"); 
176A:  CLRF   xA0
176C:  MOVF   xA0,W
176E:  MOVLB  0
1770:  CALL   0160
1774:  MOVLB  2
1776:  INCF   xA0,F
1778:  MOVWF  00
177A:  MOVWF  xB1
177C:  MOVLB  0
177E:  CALL   0430
1782:  MOVLW  12
1784:  MOVLB  2
1786:  SUBWF  xA0,W
1788:  BNZ   176C
....................    } else { 
178A:  BRA    17AC
....................       printf("Memory format not FAT16 or FAT32\r\n"); 
178C:  CLRF   xA0
178E:  MOVF   xA0,W
1790:  MOVLB  0
1792:  CALL   0184
1796:  MOVLB  2
1798:  INCF   xA0,F
179A:  MOVWF  00
179C:  MOVWF  xB1
179E:  MOVLB  0
17A0:  CALL   0430
17A4:  MOVLW  22
17A6:  MOVLB  2
17A8:  SUBWF  xA0,W
17AA:  BNZ   178E
....................    } 
....................     
....................    // Read the Volume ID to get some information important for further calculations 
....................    // If the function ReadVolumeID() returns True, it is a FAT32 volume. 
....................    if (ReadVolumeID() == TRUE) 
17AC:  MOVLB  0
17AE:  GOTO   0AFE
17B2:  DECFSZ 01,W
17B4:  GOTO   2008
....................    { 
....................        printf("Bytes per sector: %lu\r\n", BytesPerSector); 
17B8:  MOVLB  2
17BA:  CLRF   xA0
17BC:  MOVF   xA0,W
17BE:  MOVLB  0
17C0:  CALL   01B8
17C4:  MOVLB  2
17C6:  INCF   xA0,F
17C8:  MOVWF  00
17CA:  MOVWF  xB1
17CC:  MOVLB  0
17CE:  CALL   0430
17D2:  MOVLW  12
17D4:  MOVLB  2
17D6:  SUBWF  xA0,W
17D8:  BNZ   17BC
17DA:  MOVLW  10
17DC:  MOVWF  FE9
17DE:  MOVFF  226,2A2
17E2:  MOVFF  225,2A1
17E6:  MOVLB  0
17E8:  CALL   0C66
17EC:  MOVLW  0D
17EE:  MOVLB  2
17F0:  MOVWF  xB1
17F2:  MOVLB  0
17F4:  CALL   0430
17F8:  MOVLW  0A
17FA:  MOVLB  2
17FC:  MOVWF  xB1
17FE:  MOVLB  0
1800:  CALL   0430
....................        printf("Sectors per cluster: %u\r\n", SectorsPerCluster); 
1804:  MOVLB  2
1806:  CLRF   xA0
1808:  MOVF   xA0,W
180A:  MOVLB  0
180C:  CALL   01E0
1810:  MOVLB  2
1812:  INCF   xA0,F
1814:  MOVWF  00
1816:  MOVWF  xB1
1818:  MOVLB  0
181A:  CALL   0430
181E:  MOVLW  15
1820:  MOVLB  2
1822:  SUBWF  xA0,W
1824:  BNZ   1808
1826:  MOVFF  227,2A1
182A:  MOVLW  1B
182C:  MOVWF  xA2
182E:  MOVLB  0
1830:  CALL   0D50
1834:  MOVLW  0D
1836:  MOVLB  2
1838:  MOVWF  xB1
183A:  MOVLB  0
183C:  CALL   0430
1840:  MOVLW  0A
1842:  MOVLB  2
1844:  MOVWF  xB1
1846:  MOVLB  0
1848:  CALL   0430
....................        printf("Number of reserved sectors: %lu\r\n", NumberOfReservedSectors); 
184C:  MOVLB  2
184E:  CLRF   xA0
1850:  MOVF   xA0,W
1852:  MOVLB  0
1854:  CALL   020A
1858:  MOVLB  2
185A:  INCF   xA0,F
185C:  MOVWF  00
185E:  MOVWF  xB1
1860:  MOVLB  0
1862:  CALL   0430
1866:  MOVLW  1C
1868:  MOVLB  2
186A:  SUBWF  xA0,W
186C:  BNZ   1850
186E:  MOVLW  10
1870:  MOVWF  FE9
1872:  MOVFF  229,2A2
1876:  MOVFF  228,2A1
187A:  MOVLB  0
187C:  CALL   0C66
1880:  MOVLW  0D
1882:  MOVLB  2
1884:  MOVWF  xB1
1886:  MOVLB  0
1888:  CALL   0430
188C:  MOVLW  0A
188E:  MOVLB  2
1890:  MOVWF  xB1
1892:  MOVLB  0
1894:  CALL   0430
....................        printf("Number of FATs: %u\r\n", NumberOfFATs); 
1898:  MOVLB  2
189A:  CLRF   xA0
189C:  MOVF   xA0,W
189E:  MOVLB  0
18A0:  CALL   023C
18A4:  MOVLB  2
18A6:  INCF   xA0,F
18A8:  MOVWF  00
18AA:  MOVWF  xB1
18AC:  MOVLB  0
18AE:  CALL   0430
18B2:  MOVLW  10
18B4:  MOVLB  2
18B6:  SUBWF  xA0,W
18B8:  BNZ   189C
18BA:  MOVFF  22A,2A1
18BE:  MOVLW  1B
18C0:  MOVWF  xA2
18C2:  MOVLB  0
18C4:  CALL   0D50
18C8:  MOVLW  0D
18CA:  MOVLB  2
18CC:  MOVWF  xB1
18CE:  MOVLB  0
18D0:  CALL   0430
18D4:  MOVLW  0A
18D6:  MOVLB  2
18D8:  MOVWF  xB1
18DA:  MOVLB  0
18DC:  CALL   0430
....................        printf("Sectors per FAT: %lu\r\n", SectorsPerFAT); 
18E0:  MOVLB  2
18E2:  CLRF   xA0
18E4:  MOVF   xA0,W
18E6:  MOVLB  0
18E8:  CALL   0262
18EC:  MOVLB  2
18EE:  INCF   xA0,F
18F0:  MOVWF  00
18F2:  MOVWF  xB1
18F4:  MOVLB  0
18F6:  CALL   0430
18FA:  MOVLW  11
18FC:  MOVLB  2
18FE:  SUBWF  xA0,W
1900:  BNZ   18E4
1902:  MOVLW  41
1904:  MOVWF  FE9
1906:  MOVFF  22E,2A8
190A:  MOVFF  22D,2A7
190E:  MOVFF  22C,2A6
1912:  MOVFF  22B,2A5
1916:  MOVLB  0
1918:  CALL   09E0
191C:  MOVLW  0D
191E:  MOVLB  2
1920:  MOVWF  xB1
1922:  MOVLB  0
1924:  CALL   0430
1928:  MOVLW  0A
192A:  MOVLB  2
192C:  MOVWF  xB1
192E:  MOVLB  0
1930:  CALL   0430
....................        printf("Root directory first cluster: %lu\r\n", RootDirectoryFirstCluster); 
1934:  MOVLB  2
1936:  CLRF   xA0
1938:  MOVF   xA0,W
193A:  MOVLB  0
193C:  CALL   028A
1940:  MOVLB  2
1942:  INCF   xA0,F
1944:  MOVWF  00
1946:  MOVWF  xB1
1948:  MOVLB  0
194A:  CALL   0430
194E:  MOVLW  1E
1950:  MOVLB  2
1952:  SUBWF  xA0,W
1954:  BNZ   1938
1956:  MOVLW  41
1958:  MOVWF  FE9
195A:  MOVFF  232,2A8
195E:  MOVFF  231,2A7
1962:  MOVFF  230,2A6
1966:  MOVFF  22F,2A5
196A:  MOVLB  0
196C:  CALL   09E0
1970:  MOVLW  0D
1972:  MOVLB  2
1974:  MOVWF  xB1
1976:  MOVLB  0
1978:  CALL   0430
197C:  MOVLW  0A
197E:  MOVLB  2
1980:  MOVWF  xB1
1982:  MOVLB  0
1984:  CALL   0430
....................        printf("FAT begin LBA: %lu\r\n", FatBeginLBA); 
1988:  MOVLB  2
198A:  CLRF   xA0
198C:  MOVF   xA0,W
198E:  MOVLB  0
1990:  CALL   02BE
1994:  MOVLB  2
1996:  INCF   xA0,F
1998:  MOVWF  00
199A:  MOVWF  xB1
199C:  MOVLB  0
199E:  CALL   0430
19A2:  MOVLW  0F
19A4:  MOVLB  2
19A6:  SUBWF  xA0,W
19A8:  BNZ   198C
19AA:  MOVLW  41
19AC:  MOVWF  FE9
19AE:  MOVFF  23A,2A8
19B2:  MOVFF  239,2A7
19B6:  MOVFF  238,2A6
19BA:  MOVFF  237,2A5
19BE:  MOVLB  0
19C0:  CALL   09E0
19C4:  MOVLW  0D
19C6:  MOVLB  2
19C8:  MOVWF  xB1
19CA:  MOVLB  0
19CC:  CALL   0430
19D0:  MOVLW  0A
19D2:  MOVLB  2
19D4:  MOVWF  xB1
19D6:  MOVLB  0
19D8:  CALL   0430
....................        printf("Data begin LBA: %lu\r\n", DataBeginLBA+FAT16offset); 
19DC:  MOVLB  2
19DE:  MOVF   x3F,W
19E0:  ADDWF  x3B,W
19E2:  MOVWF  xA0
19E4:  MOVLW  00
19E6:  ADDWFC x3C,W
19E8:  MOVWF  xA1
19EA:  MOVLW  00
19EC:  ADDWFC x3D,W
19EE:  MOVWF  xA2
19F0:  MOVLW  00
19F2:  ADDWFC x3E,W
19F4:  MOVWF  xA3
19F6:  CLRF   xA4
19F8:  MOVF   xA4,W
19FA:  MOVLB  0
19FC:  CALL   02E4
1A00:  MOVLB  2
1A02:  INCF   xA4,F
1A04:  MOVWF  00
1A06:  MOVWF  xB1
1A08:  MOVLB  0
1A0A:  CALL   0430
1A0E:  MOVLW  10
1A10:  MOVLB  2
1A12:  SUBWF  xA4,W
1A14:  BNZ   19F8
1A16:  MOVLW  41
1A18:  MOVWF  FE9
1A1A:  MOVFF  2A3,2A8
1A1E:  MOVFF  2A2,2A7
1A22:  MOVFF  2A1,2A6
1A26:  MOVFF  2A0,2A5
1A2A:  MOVLB  0
1A2C:  CALL   09E0
1A30:  MOVLW  0D
1A32:  MOVLB  2
1A34:  MOVWF  xB1
1A36:  MOVLB  0
1A38:  CALL   0430
1A3C:  MOVLW  0A
1A3E:  MOVLB  2
1A40:  MOVWF  xB1
1A42:  MOVLB  0
1A44:  CALL   0430
....................        printf("Root Directory LBA: %lu\r\n", ComputeLBA(RootDirectoryFirstCluster)); 
1A48:  MOVFF  232,2ED
1A4C:  MOVFF  231,2EC
1A50:  MOVFF  230,2EB
1A54:  MOVFF  22F,2EA
1A58:  CALL   0DD2
1A5C:  MOVFF  03,2A3
1A60:  MOVFF  02,2A2
1A64:  MOVFF  01,2A1
1A68:  MOVFF  00,2A0
1A6C:  MOVLB  2
1A6E:  CLRF   xA4
1A70:  MOVF   xA4,W
1A72:  MOVLB  0
1A74:  CALL   030A
1A78:  MOVLB  2
1A7A:  INCF   xA4,F
1A7C:  MOVWF  00
1A7E:  MOVWF  xB1
1A80:  MOVLB  0
1A82:  CALL   0430
1A86:  MOVLW  14
1A88:  MOVLB  2
1A8A:  SUBWF  xA4,W
1A8C:  BNZ   1A70
1A8E:  MOVLW  41
1A90:  MOVWF  FE9
1A92:  MOVFF  2A3,2A8
1A96:  MOVFF  2A2,2A7
1A9A:  MOVFF  2A1,2A6
1A9E:  MOVFF  2A0,2A5
1AA2:  MOVLB  0
1AA4:  CALL   09E0
1AA8:  MOVLW  0D
1AAA:  MOVLB  2
1AAC:  MOVWF  xB1
1AAE:  MOVLB  0
1AB0:  CALL   0430
1AB4:  MOVLW  0A
1AB6:  MOVLB  2
1AB8:  MOVWF  xB1
1ABA:  MOVLB  0
1ABC:  CALL   0430
....................     
....................        printf("\r\n"); 
1AC0:  MOVLW  0D
1AC2:  MOVLB  2
1AC4:  MOVWF  xB1
1AC6:  MOVLB  0
1AC8:  CALL   0430
1ACC:  MOVLW  0A
1ACE:  MOVLB  2
1AD0:  MOVWF  xB1
1AD2:  MOVLB  0
1AD4:  CALL   0430
....................     
....................        // Open the root directory passing the Root Directory First Cluster 
....................        // to the function OpenDirectory. You can open another directory 
....................        // just passing its first cluster. 
....................        OpenDirectory(RootDirectoryFirstCluster); 
1AD8:  MOVFF  232,2A3
1ADC:  MOVFF  231,2A2
1AE0:  MOVFF  230,2A1
1AE4:  MOVFF  22F,2A0
1AE8:  GOTO   0E40
....................  
....................        // We move on through the directory looking for files. If we get some file with size 
....................        // greater than zero, we can read it. 
....................        //fd = FindNextFile(); 
....................        do 
....................        { 
....................            // Repeat the process until no more files are found 
....................            fd = FindNextFile(); 
1AEC:  GOTO   1284
1AF0:  MOVFF  02,2A1
1AF4:  MOVLB  2
1AF6:  MOVFF  01,2A0
1AFA:  MOVLW  02
1AFC:  MOVWF  FEA
1AFE:  MOVLW  64
1B00:  MOVWF  FE9
1B02:  MOVFF  02,FE2
1B06:  MOVFF  01,FE1
1B0A:  MOVLW  19
1B0C:  MOVWF  01
1B0E:  MOVFF  FE6,FEE
1B12:  DECFSZ 01,F
1B14:  BRA    1B0E
....................            if(bit_test(fd.Attributes,4)) 
1B16:  BTFSS  x70.4
1B18:  BRA    1C46
....................            { 
....................               printf("Dir:"); 
1B1A:  CLRF   xA0
1B1C:  MOVF   xA0,W
1B1E:  MOVLB  0
1B20:  CALL   0334
1B24:  MOVLB  2
1B26:  INCF   xA0,F
1B28:  MOVWF  00
1B2A:  MOVWF  xB1
1B2C:  MOVLB  0
1B2E:  CALL   0430
1B32:  MOVLW  04
1B34:  MOVLB  2
1B36:  SUBWF  xA0,W
1B38:  BNZ   1B1C
....................               for (i = 0; i < FILENAME_SIZE; i++) 
1B3A:  CLRF   x5F
1B3C:  CLRF   x5E
1B3E:  MOVF   x5F,F
1B40:  BNZ   1B6C
1B42:  MOVF   x5E,W
1B44:  SUBLW  0B
1B46:  BNC   1B6C
....................               { 
....................                   printf("%c", fd.Name[i]); 
1B48:  MOVLW  64
1B4A:  ADDWF  x5E,W
1B4C:  MOVWF  FE9
1B4E:  MOVLW  02
1B50:  ADDWFC x5F,W
1B52:  MOVWF  FEA
1B54:  MOVFF  FEF,2A0
1B58:  MOVFF  2A0,2B1
1B5C:  MOVLB  0
1B5E:  CALL   0430
....................               } 
1B62:  MOVLB  2
1B64:  INCF   x5E,F
1B66:  BTFSC  FD8.2
1B68:  INCF   x5F,F
1B6A:  BRA    1B3E
....................               printf("\r\n"); 
1B6C:  MOVLW  0D
1B6E:  MOVWF  xB1
1B70:  MOVLB  0
1B72:  CALL   0430
1B76:  MOVLW  0A
1B78:  MOVLB  2
1B7A:  MOVWF  xB1
1B7C:  MOVLB  0
1B7E:  CALL   0430
....................               printf("First LBA: %lu\r\n", fd.FirstLBA); 
1B82:  MOVLB  2
1B84:  CLRF   xA0
1B86:  MOVF   xA0,W
1B88:  MOVLB  0
1B8A:  CALL   034A
1B8E:  MOVLB  2
1B90:  INCF   xA0,F
1B92:  MOVWF  00
1B94:  MOVWF  xB1
1B96:  MOVLB  0
1B98:  CALL   0430
1B9C:  MOVLW  0B
1B9E:  MOVLB  2
1BA0:  SUBWF  xA0,W
1BA2:  BNZ   1B86
1BA4:  MOVLW  41
1BA6:  MOVWF  FE9
1BA8:  MOVFF  274,2A8
1BAC:  MOVFF  273,2A7
1BB0:  MOVFF  272,2A6
1BB4:  MOVFF  271,2A5
1BB8:  MOVLB  0
1BBA:  CALL   09E0
1BBE:  MOVLW  0D
1BC0:  MOVLB  2
1BC2:  MOVWF  xB1
1BC4:  MOVLB  0
1BC6:  CALL   0430
1BCA:  MOVLW  0A
1BCC:  MOVLB  2
1BCE:  MOVWF  xB1
1BD0:  MOVLB  0
1BD2:  CALL   0430
....................               printf("First Cluster: %lu\r\n", fd.FirstCluster); 
1BD6:  MOVLB  2
1BD8:  CLRF   xA0
1BDA:  MOVF   xA0,W
1BDC:  MOVLB  0
1BDE:  CALL   036C
1BE2:  MOVLB  2
1BE4:  INCF   xA0,F
1BE6:  MOVWF  00
1BE8:  MOVWF  xB1
1BEA:  MOVLB  0
1BEC:  CALL   0430
1BF0:  MOVLW  0F
1BF2:  MOVLB  2
1BF4:  SUBWF  xA0,W
1BF6:  BNZ   1BDA
1BF8:  MOVLW  41
1BFA:  MOVWF  FE9
1BFC:  MOVFF  27C,2A8
1C00:  MOVFF  27B,2A7
1C04:  MOVFF  27A,2A6
1C08:  MOVFF  279,2A5
1C0C:  MOVLB  0
1C0E:  CALL   09E0
1C12:  MOVLW  0D
1C14:  MOVLB  2
1C16:  MOVWF  xB1
1C18:  MOVLB  0
1C1A:  CALL   0430
1C1E:  MOVLW  0A
1C20:  MOVLB  2
1C22:  MOVWF  xB1
1C24:  MOVLB  0
1C26:  CALL   0430
....................               printf("\r\n"); 
1C2A:  MOVLW  0D
1C2C:  MOVLB  2
1C2E:  MOVWF  xB1
1C30:  MOVLB  0
1C32:  CALL   0430
1C36:  MOVLW  0A
1C38:  MOVLB  2
1C3A:  MOVWF  xB1
1C3C:  MOVLB  0
1C3E:  CALL   0430
....................            }else{ 
1C42:  BRA    1FD4
1C44:  MOVLB  2
....................              if(fd.Size > 0) 
1C46:  MOVF   x75,F
1C48:  BNZ   1C58
1C4A:  MOVF   x76,F
1C4C:  BNZ   1C58
1C4E:  MOVF   x77,F
1C50:  BNZ   1C58
1C52:  MOVF   x78,F
1C54:  BTFSC  FD8.2
1C56:  BRA    1FD6
....................              { 
....................                  // A file has been found and we display its name, size, first LBA sector, etc. 
....................                  printf("File:"); 
1C58:  CLRF   xA0
1C5A:  MOVF   xA0,W
1C5C:  MOVLB  0
1C5E:  CALL   0392
1C62:  MOVLB  2
1C64:  INCF   xA0,F
1C66:  MOVWF  00
1C68:  MOVWF  xB1
1C6A:  MOVLB  0
1C6C:  CALL   0430
1C70:  MOVLW  05
1C72:  MOVLB  2
1C74:  SUBWF  xA0,W
1C76:  BNZ   1C5A
....................                  for (i = 0; i < FILENAME_SIZE; i++) 
1C78:  CLRF   x5F
1C7A:  CLRF   x5E
1C7C:  MOVF   x5F,F
1C7E:  BNZ   1CAA
1C80:  MOVF   x5E,W
1C82:  SUBLW  0B
1C84:  BNC   1CAA
....................                  { 
....................                      printf("%c", fd.Name[i]); 
1C86:  MOVLW  64
1C88:  ADDWF  x5E,W
1C8A:  MOVWF  FE9
1C8C:  MOVLW  02
1C8E:  ADDWFC x5F,W
1C90:  MOVWF  FEA
1C92:  MOVFF  FEF,2A0
1C96:  MOVFF  2A0,2B1
1C9A:  MOVLB  0
1C9C:  CALL   0430
....................                  } 
1CA0:  MOVLB  2
1CA2:  INCF   x5E,F
1CA4:  BTFSC  FD8.2
1CA6:  INCF   x5F,F
1CA8:  BRA    1C7C
....................                  printf("\r\n"); 
1CAA:  MOVLW  0D
1CAC:  MOVWF  xB1
1CAE:  MOVLB  0
1CB0:  CALL   0430
1CB4:  MOVLW  0A
1CB6:  MOVLB  2
1CB8:  MOVWF  xB1
1CBA:  MOVLB  0
1CBC:  CALL   0430
....................                  printf("Size: %lu bytes\r\n", fd.Size); 
1CC0:  MOVLB  2
1CC2:  CLRF   xA0
1CC4:  MOVF   xA0,W
1CC6:  MOVLB  0
1CC8:  CALL   03A8
1CCC:  MOVLB  2
1CCE:  INCF   xA0,F
1CD0:  MOVWF  00
1CD2:  MOVWF  xB1
1CD4:  MOVLB  0
1CD6:  CALL   0430
1CDA:  MOVLW  06
1CDC:  MOVLB  2
1CDE:  SUBWF  xA0,W
1CE0:  BNZ   1CC4
1CE2:  MOVLW  41
1CE4:  MOVWF  FE9
1CE6:  MOVFF  278,2A8
1CEA:  MOVFF  277,2A7
1CEE:  MOVFF  276,2A6
1CF2:  MOVFF  275,2A5
1CF6:  MOVLB  0
1CF8:  CALL   09E0
1CFC:  MOVLW  09
1CFE:  MOVLB  2
1D00:  MOVWF  xA1
1D02:  MOVF   xA1,W
1D04:  MOVLB  0
1D06:  CALL   03A8
1D0A:  MOVLB  2
1D0C:  INCF   xA1,F
1D0E:  MOVWF  00
1D10:  MOVWF  xB1
1D12:  MOVLB  0
1D14:  CALL   0430
1D18:  MOVLW  11
1D1A:  MOVLB  2
1D1C:  SUBWF  xA1,W
1D1E:  BNZ   1D02
....................                  printf("First LBA: %lu\r\n", fd.FirstLBA); 
1D20:  CLRF   xA0
1D22:  MOVF   xA0,W
1D24:  MOVLB  0
1D26:  CALL   034A
1D2A:  MOVLB  2
1D2C:  INCF   xA0,F
1D2E:  MOVWF  00
1D30:  MOVWF  xB1
1D32:  MOVLB  0
1D34:  CALL   0430
1D38:  MOVLW  0B
1D3A:  MOVLB  2
1D3C:  SUBWF  xA0,W
1D3E:  BNZ   1D22
1D40:  MOVLW  41
1D42:  MOVWF  FE9
1D44:  MOVFF  274,2A8
1D48:  MOVFF  273,2A7
1D4C:  MOVFF  272,2A6
1D50:  MOVFF  271,2A5
1D54:  MOVLB  0
1D56:  CALL   09E0
1D5A:  MOVLW  0D
1D5C:  MOVLB  2
1D5E:  MOVWF  xB1
1D60:  MOVLB  0
1D62:  CALL   0430
1D66:  MOVLW  0A
1D68:  MOVLB  2
1D6A:  MOVWF  xB1
1D6C:  MOVLB  0
1D6E:  CALL   0430
....................                  printf("First Cluster: %lu\r\n", fd.FirstCluster); 
1D72:  MOVLB  2
1D74:  CLRF   xA0
1D76:  MOVF   xA0,W
1D78:  MOVLB  0
1D7A:  CALL   036C
1D7E:  MOVLB  2
1D80:  INCF   xA0,F
1D82:  MOVWF  00
1D84:  MOVWF  xB1
1D86:  MOVLB  0
1D88:  CALL   0430
1D8C:  MOVLW  0F
1D8E:  MOVLB  2
1D90:  SUBWF  xA0,W
1D92:  BNZ   1D76
1D94:  MOVLW  41
1D96:  MOVWF  FE9
1D98:  MOVFF  27C,2A8
1D9C:  MOVFF  27B,2A7
1DA0:  MOVFF  27A,2A6
1DA4:  MOVFF  279,2A5
1DA8:  MOVLB  0
1DAA:  CALL   09E0
1DAE:  MOVLW  0D
1DB0:  MOVLB  2
1DB2:  MOVWF  xB1
1DB4:  MOVLB  0
1DB6:  CALL   0430
1DBA:  MOVLW  0A
1DBC:  MOVLB  2
1DBE:  MOVWF  xB1
1DC0:  MOVLB  0
1DC2:  CALL   0430
....................                  printf("\r\n"); 
1DC6:  MOVLW  0D
1DC8:  MOVLB  2
1DCA:  MOVWF  xB1
1DCC:  MOVLB  0
1DCE:  CALL   0430
1DD2:  MOVLW  0A
1DD4:  MOVLB  2
1DD6:  MOVWF  xB1
1DD8:  MOVLB  0
1DDA:  CALL   0430
....................                   
....................                  printf("Showing file's first 32 bytes...\r\n\r\n"); 
1DDE:  MOVLB  2
1DE0:  CLRF   xA0
1DE2:  MOVF   xA0,W
1DE4:  MOVLB  0
1DE6:  CALL   03CA
1DEA:  MOVLB  2
1DEC:  INCF   xA0,F
1DEE:  MOVWF  00
1DF0:  MOVWF  xB1
1DF2:  MOVLB  0
1DF4:  CALL   0430
1DF8:  MOVLW  1D
1DFA:  MOVLB  2
1DFC:  SUBWF  xA0,W
1DFE:  BNZ   1DE2
1E00:  MOVLW  03
1E02:  MOVWF  xA1
1E04:  MOVLW  2E
1E06:  MOVWF  xB1
1E08:  MOVLB  0
1E0A:  CALL   0430
1E0E:  MOVLB  2
1E10:  DECFSZ xA1,F
1E12:  BRA    1E04
1E14:  MOVLW  1D
1E16:  MOVWF  xA2
1E18:  MOVF   xA2,W
1E1A:  MOVLB  0
1E1C:  CALL   03CA
1E20:  MOVLB  2
1E22:  INCF   xA2,F
1E24:  MOVWF  00
1E26:  MOVWF  xB1
1E28:  MOVLB  0
1E2A:  CALL   0430
1E2E:  MOVLW  21
1E30:  MOVLB  2
1E32:  SUBWF  xA2,W
1E34:  BNZ   1E18
....................                   
....................                  // Open the file obtained with FindNextFile 
....................                  OpenFile(fd); 
1E36:  MOVFF  264,2A0
1E3A:  MOVFF  265,2A1
1E3E:  MOVFF  266,2A2
1E42:  MOVFF  267,2A3
1E46:  MOVFF  268,2A4
1E4A:  MOVFF  269,2A5
1E4E:  MOVFF  26A,2A6
1E52:  MOVFF  26B,2A7
1E56:  MOVFF  26C,2A8
1E5A:  MOVFF  26D,2A9
1E5E:  MOVFF  26E,2AA
1E62:  MOVFF  26F,2AB
1E66:  MOVFF  270,2AC
1E6A:  MOVFF  271,2AD
1E6E:  MOVFF  272,2AE
1E72:  MOVFF  273,2AF
1E76:  MOVFF  274,2B0
1E7A:  MOVFF  275,2B1
1E7E:  MOVFF  276,2B2
1E82:  MOVFF  277,2B3
1E86:  MOVFF  278,2B4
1E8A:  MOVFF  279,2B5
1E8E:  MOVFF  27A,2B6
1E92:  MOVFF  27B,2B7
1E96:  MOVFF  27C,2B8
1E9A:  MOVLB  0
1E9C:  GOTO   144A
....................        
....................                  // Get some data in 32 bytes chunks. It is very important to use 
....................                  // the FILEDATA_SIZE constant. You can change this constant to use 
....................                  // another size that must be multiple of 2, like 1, 32, 64, 256, or 512. 
....................                  // The maximum buffer size allowed is 512. 
....................                  data = ReadFile(fd, FILEDATA_SIZE); 
1EA0:  MOVFF  264,2A6
1EA4:  MOVFF  265,2A7
1EA8:  MOVFF  266,2A8
1EAC:  MOVFF  267,2A9
1EB0:  MOVFF  268,2AA
1EB4:  MOVFF  269,2AB
1EB8:  MOVFF  26A,2AC
1EBC:  MOVFF  26B,2AD
1EC0:  MOVFF  26C,2AE
1EC4:  MOVFF  26D,2AF
1EC8:  MOVFF  26E,2B0
1ECC:  MOVFF  26F,2B1
1ED0:  MOVFF  270,2B2
1ED4:  MOVFF  271,2B3
1ED8:  MOVFF  272,2B4
1EDC:  MOVFF  273,2B5
1EE0:  MOVFF  274,2B6
1EE4:  MOVFF  275,2B7
1EE8:  MOVFF  276,2B8
1EEC:  MOVFF  277,2B9
1EF0:  MOVFF  278,2BA
1EF4:  MOVFF  279,2BB
1EF8:  MOVFF  27A,2BC
1EFC:  MOVFF  27B,2BD
1F00:  MOVFF  27C,2BE
1F04:  MOVLB  2
1F06:  CLRF   xC2
1F08:  CLRF   xC1
1F0A:  CLRF   xC0
1F0C:  MOVLW  20
1F0E:  MOVWF  xBF
1F10:  MOVLB  0
1F12:  GOTO   149E
1F16:  MOVFF  02,2A1
1F1A:  MOVLB  2
1F1C:  MOVFF  01,2A0
1F20:  MOVLW  02
1F22:  MOVWF  FEA
1F24:  MOVLW  7D
1F26:  MOVWF  FE9
1F28:  MOVFF  02,FE2
1F2C:  MOVFF  01,FE1
1F30:  MOVLW  23
1F32:  MOVWF  01
1F34:  MOVFF  FE6,FEE
1F38:  DECFSZ 01,F
1F3A:  BRA    1F34
....................                    
....................                  // Show file's first 32 bytes 
....................                  c = 0; 
1F3C:  CLRF   x63
1F3E:  CLRF   x62
....................                  for (i = 0; i < 2; i++) 
1F40:  CLRF   x5F
1F42:  CLRF   x5E
1F44:  MOVF   x5F,F
1F46:  BNZ   1FB6
1F48:  MOVF   x5E,W
1F4A:  SUBLW  01
1F4C:  BNC   1FB6
....................                  { 
....................                      for (j = 0; j < 16; j++) 
1F4E:  CLRF   x61
1F50:  CLRF   x60
1F52:  MOVF   x61,F
1F54:  BNZ   1F96
1F56:  MOVF   x60,W
1F58:  SUBLW  0F
1F5A:  BNC   1F96
....................                      { 
....................                         printf("%2X ", data.Buffer[c]); 
1F5C:  MOVLW  7D
1F5E:  ADDWF  x62,W
1F60:  MOVWF  FE9
1F62:  MOVLW  02
1F64:  ADDWFC x63,W
1F66:  MOVWF  FEA
1F68:  MOVFF  FEF,2A0
1F6C:  MOVFF  2A0,2A1
1F70:  MOVLW  37
1F72:  MOVWF  xA2
1F74:  MOVLB  0
1F76:  GOTO   1656
1F7A:  MOVLW  20
1F7C:  MOVLB  2
1F7E:  MOVWF  xB1
1F80:  MOVLB  0
1F82:  CALL   0430
....................                         c++; 
1F86:  MOVLB  2
1F88:  INCF   x62,F
1F8A:  BTFSC  FD8.2
1F8C:  INCF   x63,F
....................                      } 
1F8E:  INCF   x60,F
1F90:  BTFSC  FD8.2
1F92:  INCF   x61,F
1F94:  BRA    1F52
....................                      printf("\r\n"); 
1F96:  MOVLW  0D
1F98:  MOVWF  xB1
1F9A:  MOVLB  0
1F9C:  CALL   0430
1FA0:  MOVLW  0A
1FA2:  MOVLB  2
1FA4:  MOVWF  xB1
1FA6:  MOVLB  0
1FA8:  CALL   0430
....................                  } 
1FAC:  MOVLB  2
1FAE:  INCF   x5E,F
1FB0:  BTFSC  FD8.2
1FB2:  INCF   x5F,F
1FB4:  BRA    1F44
....................                   
....................                  // Close the opened file handlers 
....................                  CloseFile(); 
1FB6:  MOVLB  0
1FB8:  GOTO   16A2
....................                   
....................                  printf("\r\n"); 
1FBC:  MOVLW  0D
1FBE:  MOVLB  2
1FC0:  MOVWF  xB1
1FC2:  MOVLB  0
1FC4:  CALL   0430
1FC8:  MOVLW  0A
1FCA:  MOVLB  2
1FCC:  MOVWF  xB1
1FCE:  MOVLB  0
1FD0:  CALL   0430
1FD4:  MOVLB  2
....................              } 
....................           } 
....................        }while(!EODReached); 
1FD6:  BTFSC  x4B.1
1FD8:  BRA    1FDE
1FDA:  MOVLB  0
1FDC:  BRA    1AEC
....................     
....................        // Close the directory handlers 
....................        CloseDirectory(); 
1FDE:  MOVLB  0
1FE0:  GOTO   16AC
....................     
....................        // Display a final message 
....................        printf("No more files in root directory!\r\n"); 
1FE4:  MOVLB  2
1FE6:  CLRF   xA0
1FE8:  MOVF   xA0,W
1FEA:  MOVLB  0
1FEC:  CALL   03FC
1FF0:  MOVLB  2
1FF2:  INCF   xA0,F
1FF4:  MOVWF  00
1FF6:  MOVWF  xB1
1FF8:  MOVLB  0
1FFA:  CALL   0430
1FFE:  MOVLW  22
2000:  MOVLB  2
2002:  SUBWF  xA0,W
2004:  BNZ   1FE8
2006:  MOVLB  0
....................    } 
....................     
....................    while (TRUE); 
2008:  BRA    2008
.................... } 
....................  
200A:  SLEEP 

Configuration Fuses:
   Word  1: 0C20   NOIESO NOFCMEN HS PLL1 CPUDIV1 USBDIV
   Word  2: 1E19   NOBROWNOUT NOWDT BORV20 NOPUT WDT32768 NOVREGEN RESERVED
   Word  3: 8300   PBADEN CCP2C1 MCLR NOLPT1OSC RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB

CCS PCH C Compiler, Version 4.038, 15507               16-nov-10 10:50

               Filename: D:\Proyectos\Electrónica\nanofat-lib\trunk\fattest.lst

               ROM used: 8180 bytes (25%)
                         Largest free fragment is 24588
               RAM used: 677 (33%) at main() level
                         788 (38%) worst case
               Stack:    6 locations

*
0000:  GOTO   1624
.................... #include "fattest.h" 
.................... #include <18F2550.h> 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
....................  
.................... #use delay(clock=20000000) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_B7,rcv=PIN_B6,bits=8) 
*
05FA:  BCF    F93.7
05FC:  BCF    F8A.7
05FE:  MOVLW  08
0600:  MOVWF  01
0602:  BRA    0604
0604:  NOP   
0606:  BSF    01.7
0608:  BRA    062A
060A:  BCF    01.7
060C:  MOVLB  2
060E:  RRCF   xB1,F
0610:  MOVLB  0
0612:  BTFSC  FD8.0
0614:  BSF    F8A.7
0616:  BTFSS  FD8.0
0618:  BCF    F8A.7
061A:  BSF    01.6
061C:  BRA    062A
061E:  BCF    01.6
0620:  DECFSZ 01,F
0622:  BRA    060C
0624:  BRA    0626
0626:  NOP   
0628:  BSF    F8A.7
062A:  MOVLW  08
062C:  MOVWF  FE9
062E:  DECFSZ FE9,F
0630:  BRA    062E
0632:  NOP   
0634:  BTFSC  01.7
0636:  BRA    060A
0638:  BTFSC  01.6
063A:  BRA    061E
063C:  RETLW  00
.................... #use SPI(FORCE_HW) 
....................  
.................... #include "sddriver.h" 
.................... #byte LATA = 0xF89 
.................... #byte TRISA = 0xF92 
.................... #byte SSPSTAT = 0xFC7 
.................... #byte SSPCON1 = 0xFC6 
.................... #byte TRISB = 0xF93 
.................... #byte LATB = 0xF8A 
.................... #byte TRISC = 0xF94 
.................... #byte LATC = 0xF8B 
.................... #byte PORTB = 0xF81 
....................  
.................... #bit SDI_TRIS = TRISB.0 
.................... #bit SCK_TRIS = TRISB.1 
.................... #bit SDO_TRIS = TRISC.7 
.................... #bit SDI = PORTB.0 
.................... #bit SCK = LATB.1 
.................... #bit SDO = LATC.7 
....................  
.................... #bit SD_CS = LATA.5 
.................... #bit SD_CS_TRIS = TRISA.5 
.................... #bit CKE = SSPSTAT.6 
.................... #bit SMP = SSPSTAT.7 
.................... #bit CKP = SSPCON1.4 
.................... #bit SSPEN = SSPCON1.5 
....................  
.................... #define SPI_DIV_4    0x00 
.................... #define SPI_DIV_16   0x01 
.................... #define SPI_DIV_64   0x02 
....................  
.................... #define SPI_IDLE_HIGH   1 
.................... #define SPI_IDLE_LOW    0 
....................  
.................... #define SPI_TX_LOW_TO_HIGH 0 
.................... #define SPI_TX_HIGH_TO_LOW 1 
....................  
.................... #define SPI_SAMPLE_END     1 
.................... #define SPI_SAMPLE_MIDDLE  0 
....................  
.................... #define SpiEnable()    { SSPEN = 1; } 
.................... #define SpiDisable()   { SSPEN = 0; } 
....................  
.................... #define SDAssert()     { SD_CS = 0; } 
.................... #define SDDeassert()   { SD_CS = 1; } 
....................  
.................... #ifndef TRUE 
.................... #define TRUE 1 
.................... #endif 
....................  
.................... #ifndef FALSE 
.................... #define FALSE 0 
.................... #endif 
....................  
.................... void SpiSetDivisor(BYTE divisor) 
.................... { 
....................    SSPCON1 = (SSPCON1 & 0xF0) | divisor; 
*
039A:  MOVF   FC6,W
039C:  ANDLW  F0
039E:  MOVLB  3
03A0:  IORWF  x0B,W
03A2:  MOVWF  FC6
.................... } 
03A4:  MOVLB  0
03A6:  GOTO   03E0 (RETURN)
....................  
.................... void SpiSetClockPolarity(unsigned int1 polarity) 
.................... { 
....................    CKP = polarity; 
*
03B8:  BCF    FC6.4
03BA:  MOVLB  3
03BC:  BTFSC  x0B.0
03BE:  BSF    FC6.4
.................... } 
03C0:  MOVLB  0
03C2:  GOTO   03F2 (RETURN)
....................  
.................... void SpiSetTXTransition(unsigned int1 direction) 
.................... { 
....................    CKE = direction; 
*
03AA:  BCF    FC7.6
03AC:  MOVLB  3
03AE:  BTFSC  x0B.0
03B0:  BSF    FC7.6
.................... } 
03B2:  MOVLB  0
03B4:  GOTO   03E8 (RETURN)
....................  
.................... void SpiSetSampleMode(unsigned int1 mode) 
.................... { 
....................    SMP = mode; 
*
03C6:  BCF    FC7.7
03C8:  MOVLB  3
03CA:  BTFSC  x0B.0
03CC:  BSF    FC7.7
.................... } 
03CE:  MOVLB  0
03D0:  GOTO   03FA (RETURN)
....................  
.................... void SpiInit(void) 
.................... { 
....................    SDI_TRIS = 1; 
*
0390:  BSF    F93.0
....................    SDO_TRIS = 0; 
0392:  BCF    F94.7
....................    SCK_TRIS = 0; 
0394:  BCF    F93.1
.................... } 
0396:  GOTO   03DA (RETURN)
....................  
.................... BYTE SDResponse(BYTE expected_response) 
.................... { 
....................    unsigned int16 count = 0x0FFF; 
*
03FE:  MOVLW  FF
0400:  MOVLB  3
0402:  MOVWF  x0B
0404:  MOVLW  0F
0406:  MOVWF  x0C
....................     
....................    while ((SPI_READ(0xFF) != expected_response) && (--count > 0)); 
0408:  MOVF   FC9,W
040A:  MOVLW  FF
040C:  MOVWF  FC9
040E:  BTFSS  FC7.0
0410:  BRA    040E
0412:  MOVF   x0A,W
0414:  SUBWF  FC9,W
0416:  BZ    0426
0418:  MOVF   x0B,W
041A:  BTFSC  FD8.2
041C:  DECF   x0C,F
041E:  DECFSZ x0B,F
0420:  BRA    0408
0422:  MOVF   x0C,F
0424:  BNZ   0408
....................     
....................    if (count == 0) 
0426:  MOVF   x0B,F
0428:  BNZ   0436
042A:  MOVF   x0C,F
042C:  BNZ   0436
....................    { 
....................       return FALSE; 
042E:  MOVLW  00
0430:  MOVWF  01
0432:  BRA    043C
....................    } else { 
0434:  BRA    043C
....................       return TRUE; 
0436:  MOVLW  01
0438:  MOVWF  01
043A:  BRA    043C
....................    } 
.................... } 
043C:  MOVLB  0
043E:  RETLW  00
....................  
.................... void SDConfigure(BYTE divisor) 
.................... { 
....................    // Set SD chip select pin direction 
....................    SD_CS_TRIS = 0; 
*
03D4:  BCF    F92.5
....................  
....................    // Disable the SPI module if enabled 
....................    SpiDisable(); 
03D6:  BCF    FC6.5
....................     
....................    // Initialize the SPI port if not initialized 
....................    SpiInit(); 
03D8:  BRA    0390
....................     
....................    // Slow down the SPI speed to minimum 
....................    SpiSetDivisor(divisor); 
03DA:  MOVFF  30A,30B
03DE:  BRA    039A
....................     
....................    // Set SPI protocol parameters 
....................    SpiSetTXTransition(SPI_TX_LOW_TO_HIGH);   // CKE = 0 
03E0:  MOVLB  3
03E2:  CLRF   x0B
03E4:  MOVLB  0
03E6:  BRA    03AA
....................    SpiSetClockPolarity(SPI_IDLE_HIGH);       // CKP = 1 
03E8:  MOVLW  01
03EA:  MOVLB  3
03EC:  MOVWF  x0B
03EE:  MOVLB  0
03F0:  BRA    03B8
....................    SpiSetSampleMode(SPI_SAMPLE_MIDDLE);      // SMP = 0 
03F2:  MOVLB  3
03F4:  CLRF   x0B
03F6:  MOVLB  0
03F8:  BRA    03C6
....................     
....................    // Enable the SPI port 
....................    SpiEnable(); 
03FA:  BSF    FC6.5
.................... } 
03FC:  RETLW  00
....................  
.................... BYTE SDInit(void) 
.................... { 
....................    BYTE res; 
....................    unsigned int16 timeout; 
....................     
....................    // Configure SD chip select 
....................    SDDeassert(); 
*
0440:  BSF    F89.5
....................    SDConfigure(SPI_DIV_64); 
0442:  MOVLW  02
0444:  MOVLB  3
0446:  MOVWF  x0A
0448:  MOVLB  0
044A:  RCALL  03D4
....................     
....................    // Send at least 74 clocks 
....................    Spi_Write(0xFF); 
044C:  MOVF   FC9,W
044E:  MOVLW  FF
0450:  MOVWF  FC9
0452:  BTFSS  FC7.0
0454:  BRA    0452
....................    Spi_Write(0xFF); 
0456:  MOVF   FC9,W
0458:  MOVLW  FF
045A:  MOVWF  FC9
045C:  BTFSS  FC7.0
045E:  BRA    045C
....................    Spi_Write(0xFF); 
0460:  MOVF   FC9,W
0462:  MOVLW  FF
0464:  MOVWF  FC9
0466:  BTFSS  FC7.0
0468:  BRA    0466
....................    Spi_Write(0xFF); 
046A:  MOVF   FC9,W
046C:  MOVLW  FF
046E:  MOVWF  FC9
0470:  BTFSS  FC7.0
0472:  BRA    0470
....................    Spi_Write(0xFF); 
0474:  MOVF   FC9,W
0476:  MOVLW  FF
0478:  MOVWF  FC9
047A:  BTFSS  FC7.0
047C:  BRA    047A
....................    Spi_Write(0xFF); 
047E:  MOVF   FC9,W
0480:  MOVLW  FF
0482:  MOVWF  FC9
0484:  BTFSS  FC7.0
0486:  BRA    0484
....................    Spi_Write(0xFF); 
0488:  MOVF   FC9,W
048A:  MOVLW  FF
048C:  MOVWF  FC9
048E:  BTFSS  FC7.0
0490:  BRA    048E
....................    Spi_Write(0xFF); 
0492:  MOVF   FC9,W
0494:  MOVLW  FF
0496:  MOVWF  FC9
0498:  BTFSS  FC7.0
049A:  BRA    0498
....................    Spi_Write(0xFF); 
049C:  MOVF   FC9,W
049E:  MOVLW  FF
04A0:  MOVWF  FC9
04A2:  BTFSS  FC7.0
04A4:  BRA    04A2
....................    Spi_Write(0xFF); 
04A6:  MOVF   FC9,W
04A8:  MOVLW  FF
04AA:  MOVWF  FC9
04AC:  BTFSS  FC7.0
04AE:  BRA    04AC
....................     
....................    // Assert the SD line 
....................    SDAssert(); 
04B0:  BCF    F89.5
....................     
....................    // Send CMD0 to the SD card 
....................    Spi_Write(0x40); 
04B2:  MOVF   FC9,W
04B4:  MOVLW  40
04B6:  MOVWF  FC9
04B8:  BTFSS  FC7.0
04BA:  BRA    04B8
....................    Spi_Write(0x00); 
04BC:  MOVF   FC9,W
04BE:  CLRF   FC9
04C0:  BTFSS  FC7.0
04C2:  BRA    04C0
....................    Spi_Write(0x00); 
04C4:  MOVF   FC9,W
04C6:  CLRF   FC9
04C8:  BTFSS  FC7.0
04CA:  BRA    04C8
....................    Spi_Write(0x00); 
04CC:  MOVF   FC9,W
04CE:  CLRF   FC9
04D0:  BTFSS  FC7.0
04D2:  BRA    04D0
....................    Spi_Write(0x00); 
04D4:  MOVF   FC9,W
04D6:  CLRF   FC9
04D8:  BTFSS  FC7.0
04DA:  BRA    04D8
....................    Spi_Write(0x95); 
04DC:  MOVF   FC9,W
04DE:  MOVLW  95
04E0:  MOVWF  FC9
04E2:  BTFSS  FC7.0
04E4:  BRA    04E2
....................     
....................    // Wait for the memory to be in idle state 
....................    if (SDResponse(0x01) == FALSE) 
04E6:  MOVLW  01
04E8:  MOVLB  3
04EA:  MOVWF  x0A
04EC:  MOVLB  0
04EE:  RCALL  03FE
04F0:  MOVF   01,F
04F2:  BNZ   04FA
....................    { 
....................       //printf("No response from SD card!\r\n"); 
....................       return FALSE; 
04F4:  MOVLW  00
04F6:  MOVWF  01
04F8:  BRA    05F6
....................    } 
....................     
....................    // De-assert the SD from the SPI bus 
....................    SDDeassert(); 
04FA:  BSF    F89.5
....................     
....................    // Some extra clocks 
....................    Spi_Write(0xFF); 
04FC:  MOVF   FC9,W
04FE:  MOVLW  FF
0500:  MOVWF  FC9
0502:  BTFSS  FC7.0
0504:  BRA    0502
....................     
....................    // Send CMD1 to initialize the card 
....................    timeout = 0; 
0506:  MOVLB  2
0508:  CLRF   xA2
050A:  CLRF   xA1
....................    while (timeout < 0x0FFF) 
....................    { 
050C:  MOVF   xA2,W
050E:  SUBLW  0F
0510:  BNC   0586
0512:  BNZ   051A
0514:  MOVF   xA1,W
0516:  SUBLW  FE
0518:  BNC   0586
....................       timeout++; 
051A:  INCF   xA1,F
051C:  BTFSC  FD8.2
051E:  INCF   xA2,F
....................        
....................       // Assert the SD card 
....................       SDAssert(); 
0520:  BCF    F89.5
....................        
....................       // Send CMD1 
....................       Spi_Write(0x41); 
0522:  MOVF   FC9,W
0524:  MOVLW  41
0526:  MOVWF  FC9
0528:  BTFSS  FC7.0
052A:  BRA    0528
....................       Spi_Write(0x00); 
052C:  MOVF   FC9,W
052E:  CLRF   FC9
0530:  BTFSS  FC7.0
0532:  BRA    0530
....................       Spi_Write(0x00); 
0534:  MOVF   FC9,W
0536:  CLRF   FC9
0538:  BTFSS  FC7.0
053A:  BRA    0538
....................       Spi_Write(0x00); 
053C:  MOVF   FC9,W
053E:  CLRF   FC9
0540:  BTFSS  FC7.0
0542:  BRA    0540
....................       Spi_Write(0x00); 
0544:  MOVF   FC9,W
0546:  CLRF   FC9
0548:  BTFSS  FC7.0
054A:  BRA    0548
....................       Spi_Write(0xFF); 
054C:  MOVF   FC9,W
054E:  MOVLW  FF
0550:  MOVWF  FC9
0552:  BTFSS  FC7.0
0554:  BRA    0552
....................        
....................       // Check for CMD1 response 
....................       if (SDResponse(0x00) == TRUE) 
0556:  MOVLB  3
0558:  CLRF   x0A
055A:  MOVLB  0
055C:  RCALL  03FE
055E:  DECFSZ 01,W
0560:  BRA    0576
....................       { 
....................          // Got expected response, break out of loop 
....................          SDDeassert(); 
0562:  BSF    F89.5
....................          Spi_Write(0xFF); 
0564:  MOVF   FC9,W
0566:  MOVLW  FF
0568:  MOVWF  FC9
056A:  BTFSS  FC7.0
056C:  BRA    056A
....................          break; 
056E:  MOVLB  2
0570:  BRA    0586
....................       } else { 
0572:  BRA    0584
0574:  MOVLB  0
....................          // must have timed out waiting for response, so loop again       
....................          SDDeassert(); 
0576:  BSF    F89.5
....................          Spi_Write(0xFF); 
0578:  MOVF   FC9,W
057A:  MOVLW  FF
057C:  MOVWF  FC9
057E:  BTFSS  FC7.0
0580:  BRA    057E
0582:  MOVLB  2
....................       } 
....................    } 
0584:  BRA    050C
....................     
....................    // Check if we have a time out 
....................    if (timeout >= 0xFE) return FALSE; 
0586:  MOVF   xA2,F
0588:  BNZ   0590
058A:  MOVF   xA1,W
058C:  SUBLW  FD
058E:  BC    059A
0590:  MOVLW  00
0592:  MOVWF  01
0594:  MOVLB  0
0596:  BRA    05F6
0598:  MOVLB  2
....................     
....................    // De-assert the SD card from the SPI bus 
....................    SDDeassert(); 
059A:  BSF    F89.5
....................     
....................    // Extra clocks 
....................    Spi_Write(0xFF); 
059C:  MOVF   FC9,W
059E:  MOVLW  FF
05A0:  MOVWF  FC9
05A2:  BTFSS  FC7.0
05A4:  BRA    05A2
....................     
....................    // Assert the SD card 
....................    SDAssert(); 
05A6:  BCF    F89.5
....................     
....................    // Set the block size (512 bytes) 
....................    Spi_Write(0x50); 
05A8:  MOVF   FC9,W
05AA:  MOVLW  50
05AC:  MOVWF  FC9
05AE:  BTFSS  FC7.0
05B0:  BRA    05AE
....................    Spi_Write(0x00); 
05B2:  MOVF   FC9,W
05B4:  CLRF   FC9
05B6:  BTFSS  FC7.0
05B8:  BRA    05B6
....................    Spi_Write(0x00); 
05BA:  MOVF   FC9,W
05BC:  CLRF   FC9
05BE:  BTFSS  FC7.0
05C0:  BRA    05BE
....................    Spi_Write(0x02); 
05C2:  MOVF   FC9,W
05C4:  MOVLW  02
05C6:  MOVWF  FC9
05C8:  BTFSS  FC7.0
05CA:  BRA    05C8
....................    Spi_Write(0x00); 
05CC:  MOVF   FC9,W
05CE:  CLRF   FC9
05D0:  BTFSS  FC7.0
05D2:  BRA    05D0
....................    Spi_Write(0xFF); 
05D4:  MOVF   FC9,W
05D6:  MOVLW  FF
05D8:  MOVWF  FC9
05DA:  BTFSS  FC7.0
05DC:  BRA    05DA
....................     
....................    if (SDResponse(0x00) == FALSE) 
05DE:  MOVLB  3
05E0:  CLRF   x0A
05E2:  MOVLB  0
05E4:  RCALL  03FE
05E6:  MOVF   01,F
05E8:  BNZ   05F0
....................    { 
....................       return FALSE; 
05EA:  MOVLW  00
05EC:  MOVWF  01
05EE:  BRA    05F6
....................    } 
....................     
....................    // De-assert the SD card from the SPI bus 
....................    SDDeassert(); 
05F0:  BSF    F89.5
....................     
....................    // The card should has been initialized successfuly 
....................    return TRUE; 
05F2:  MOVLW  01
05F4:  MOVWF  01
.................... } 
05F6:  GOTO   1654 (RETURN)
....................  
.................... BYTE SDOpenBlockForReading(unsigned int32 block_number) 
.................... { 
....................    unsigned int16 i; 
....................     
....................    SDDeassert(); 
*
063E:  BSF    F89.5
....................    SDConfigure(SPI_DIV_4); 
0640:  MOVLB  3
0642:  CLRF   x0A
0644:  MOVLB  0
0646:  RCALL  03D4
....................     
....................    SDAssert(); 
0648:  BCF    F89.5
....................     
....................    block_number *= 512; 
064A:  BCF    FD8.0
064C:  MOVFF  306,307
0650:  MOVFF  305,306
0654:  MOVFF  304,305
0658:  MOVLB  3
065A:  CLRF   x04
065C:  RLCF   x05,F
065E:  RLCF   x06,F
0660:  RLCF   x07,F
....................     
....................    // Send read command 
....................    Spi_Write(0x51); 
0662:  MOVF   FC9,W
0664:  MOVLW  51
0666:  MOVWF  FC9
0668:  BTFSS  FC7.0
066A:  BRA    0668
....................    Spi_Write((BYTE)(block_number >> 24)); 
066C:  MOVFF  307,00
0670:  CLRF   01
0672:  CLRF   02
0674:  CLRF   03
0676:  MOVFF  307,30B
067A:  MOVF   FC9,W
067C:  MOVFF  307,FC9
0680:  BTFSS  FC7.0
0682:  BRA    0680
....................    Spi_Write((BYTE)(block_number >> 16)); 
0684:  MOVFF  306,00
0688:  MOVFF  307,01
068C:  CLRF   02
068E:  CLRF   03
0690:  MOVFF  306,30B
0694:  MOVF   FC9,W
0696:  MOVFF  306,FC9
069A:  BTFSS  FC7.0
069C:  BRA    069A
....................    Spi_Write((BYTE)(block_number >> 8)); 
069E:  MOVFF  305,00
06A2:  MOVFF  306,01
06A6:  MOVFF  307,02
06AA:  CLRF   03
06AC:  MOVFF  305,30B
06B0:  MOVF   FC9,W
06B2:  MOVFF  305,FC9
06B6:  BTFSS  FC7.0
06B8:  BRA    06B6
....................    Spi_Write((BYTE)(block_number)); 
06BA:  MOVF   FC9,W
06BC:  MOVFF  304,FC9
06C0:  BTFSS  FC7.0
06C2:  BRA    06C0
....................    Spi_Write(0xFF); 
06C4:  MOVF   FC9,W
06C6:  MOVLW  FF
06C8:  MOVWF  FC9
06CA:  BTFSS  FC7.0
06CC:  BRA    06CA
....................     
....................    // Wait for response... exit if timeout 
....................    if (SDResponse(0x00) == FALSE) return FALSE; 
06CE:  CLRF   x0A
06D0:  MOVLB  0
06D2:  RCALL  03FE
06D4:  MOVF   01,F
06D6:  BNZ   06DE
06D8:  MOVLW  00
06DA:  MOVWF  01
06DC:  BRA    06F6
....................     
....................    // Wait for data token 
....................    if (SDResponse(0xFE) == FALSE) return FALSE; 
06DE:  MOVLW  FE
06E0:  MOVLB  3
06E2:  MOVWF  x0A
06E4:  MOVLB  0
06E6:  RCALL  03FE
06E8:  MOVF   01,F
06EA:  BNZ   06F2
06EC:  MOVLW  00
06EE:  MOVWF  01
06F0:  BRA    06F6
....................     
....................    return TRUE; 
06F2:  MOVLW  01
06F4:  MOVWF  01
.................... } 
06F6:  GOTO   0726 (RETURN)
....................  
.................... BYTE SDOpenBlockForWriting(unsigned int32 block_number) 
.................... { 
....................    unsigned int16 i; 
....................     
....................    SDDeassert(); 
....................    SDConfigure(SPI_DIV_4); 
....................     
....................    SDAssert(); 
....................     
....................    block_number *= 512; 
....................     
....................    // Send read command 
....................    Spi_Write(0x51); 
....................    Spi_Write((BYTE)(block_number >> 24)); 
....................    Spi_Write((BYTE)(block_number >> 16)); 
....................    Spi_Write((BYTE)(block_number >> 8)); 
....................    Spi_Write((BYTE)(block_number)); 
....................    Spi_Write(0xFF); 
....................     
....................    // Wait for response... exit if timeout 
....................    if (SDResponse(0x00) == FALSE) return FALSE; 
....................     
....................    // Send data token 
....................    Spi_Write(0xFE); 
....................     
....................    return TRUE; 
.................... } 
....................  
.................... void SDCloseReadBlock() 
.................... { 
....................    // Dummy CRC 
....................    Spi_Write(0xFF); 
06FA:  MOVF   FC9,W
06FC:  MOVLW  FF
06FE:  MOVWF  FC9
0700:  BTFSS  FC7.0
0702:  BRA    0700
....................    Spi_Write(0xFF); 
0704:  MOVF   FC9,W
0706:  MOVLW  FF
0708:  MOVWF  FC9
070A:  BTFSS  FC7.0
070C:  BRA    070A
....................     
....................    SDDeassert(); 
070E:  BSF    F89.5
....................     
....................    SpiDisable(); 
0710:  BCF    FC6.5
.................... } 
0712:  RETLW  00
....................  
.................... BYTE SDCloseWrittenBlock() 
.................... { 
....................    unsigned int16 timeout; 
....................    BYTE response; 
....................     
....................    timeout = 0x0FFF; 
....................    response = TRUE; 
....................     
....................    // Dummy CRC 
....................    Spi_Write(0xFF); 
....................    Spi_Write(0xFF); 
....................     
....................    // Wait for SD to be ready 
....................    while (((Spi_Read(0xFF) & 0x1F) != 0x05) && timeout) 
....................    { 
....................       timeout--; 
....................    } 
....................     
....................    if (timeout == 0) 
....................    { 
....................       response = FALSE; 
....................    } 
....................     
....................    SDDeassert(); 
....................     
....................    SpiDisable(); 
....................     
....................    return response; 
.................... } 
....................  
.................... #include "fatdriver.h" 
.................... // Boolean values if not defined 
.................... #ifndef TRUE 
.................... #define TRUE 1 
.................... #endif 
....................  
.................... #ifndef FALSE 
.................... #define FALSE 0 
.................... #endif 
....................  
.................... // Constants used when determining Directory Entry types 
.................... #define EOD 0 
.................... #define UNUSED 1 
.................... #define LFNAME 2 
.................... #define NFNAME 3 
.................... #define NDNAME 4 //Normal directory 
....................  
.................... // Global constants used by the FAT32 file system 
.................... #define BUFFER_SIZE 512 
.................... #define DIRENTRY_SIZE 32 
.................... #define FILENAME_SIZE 12 
.................... #define FILEDATA_SIZE 32 
.................... #define PARTITION_ENTRY_SIZE  16 
....................  
.................... #define FIRST_PARTITION_ENTRY 0x1BE 
....................  
.................... // Buffers used to temporarily save the obtained data 
.................... BYTE SectorBuffer[BUFFER_SIZE]; 
.................... BYTE DirEntry[DIRENTRY_SIZE]; 
....................  
.................... // Volume ID information 
.................... unsigned int16 BytesPerSector; 
.................... unsigned BYTE  SectorsPerCluster; 
.................... unsigned int16 NumberOfReservedSectors; 
.................... unsigned BYTE  NumberOfFATs; 
.................... unsigned int32 SectorsPerFAT; 
.................... unsigned int32 RootDirectoryFirstCluster; 
....................  
.................... // Information related to partitions and FAT table 
.................... unsigned int32 PartitionLBABegin; 
.................... unsigned int32 FatBeginLBA; 
.................... //unsigned int32 ClusterBeginLBA; 
.................... unsigned int32 DataBeginLBA; 
.................... unsigned int8  FAT16Offset; 
....................  
.................... // Variables used to store the position of current entry 
.................... // when reading directory contents. 
.................... unsigned int32 DirectoryCurrentCluster; 
.................... unsigned int32 DirectoryCurrentLBA; 
.................... unsigned BYTE DirectoryCurrentDirEntry; 
.................... unsigned int16 DirectoryCurrentSector; 
.................... unsigned BOOLEAN DirectoryOpened; 
.................... unsigned BOOLEAN EODReached; 
....................  
.................... // Variables used to store file information when reading 
.................... unsigned int32 FileCurrentCluster; 
.................... unsigned int32 FileCurrentLBA; 
.................... unsigned int16 FileCurrentSector; 
.................... unsigned int32 FileLengthCount; 
.................... unsigned int16 FileSectorPosition; 
.................... unsigned BOOLEAN FileOpened; 
....................  
.................... // File descriptor structure 
.................... typedef struct 
.................... { 
....................    unsigned BYTE Name[FILENAME_SIZE]; 
....................    unsigned int8  Attributes; 
....................    unsigned int32 FirstLBA; 
....................    unsigned int32 Size; 
....................    unsigned int32 FirstCluster; 
.................... } FILEDESCRIPTOR; 
....................  
.................... //A partition Entry structure 
.................... typedef struct 
.................... {    
....................    unsigned short IsValid; 
....................    unsigned short IsFAT32; 
....................    BYTE Type; 
.................... } PARTITIONENTRY; 
....................  
.................... // File data structure 
.................... typedef struct 
.................... { 
....................    unsigned BYTE Buffer[FILEDATA_SIZE]; 
....................    unsigned int16 BytesRead; 
....................    unsigned BOOLEAN EOF; 
.................... } FILEDATA; 
....................  
.................... PARTITIONENTRY pEntry; 
....................  
.................... // -- Start of Code Section ------------- 
....................  
.................... BOOLEAN ReadSector(unsigned int32 lba) 
.................... { 
....................    unsigned long i; 
....................     
....................    if (SDOpenBlockForReading(lba) == TRUE) 
0714:  MOVFF  301,307
0718:  MOVFF  300,306
071C:  MOVFF  2FF,305
0720:  MOVFF  2FE,304
0724:  BRA    063E
0726:  DECFSZ 01,W
0728:  BRA    0764
....................    { 
....................       for (i = 0; i < BUFFER_SIZE; i++) 
072A:  MOVLB  3
072C:  CLRF   x03
072E:  CLRF   x02
0730:  MOVF   x03,W
0732:  SUBLW  01
0734:  BNC   0758
....................       { 
....................          SectorBuffer[i] = Spi_Read(0xFF); 
0736:  MOVLW  05
0738:  ADDWF  x02,W
073A:  MOVWF  FE9
073C:  MOVLW  00
073E:  ADDWFC x03,W
0740:  MOVWF  FEA
0742:  MOVF   FC9,W
0744:  MOVLW  FF
0746:  MOVWF  FC9
0748:  BTFSS  FC7.0
074A:  BRA    0748
074C:  MOVFF  FC9,FEF
....................       } 
0750:  INCF   x02,F
0752:  BTFSC  FD8.2
0754:  INCF   x03,F
0756:  BRA    0730
....................        
....................       SDCloseReadBlock(); 
0758:  MOVLB  0
075A:  RCALL  06FA
....................       return TRUE; 
075C:  MOVLW  01
075E:  MOVWF  01
0760:  BRA    076C
....................    } else { 
0762:  BRA    076C
....................       SDCloseReadBlock(); 
0764:  RCALL  06FA
....................       return FALSE; 
0766:  MOVLW  00
0768:  MOVWF  01
076A:  BRA    076C
....................    } 
.................... } 
076C:  RETLW  00
....................  
.................... void ReadDirEntry(BYTE num) 
.................... { 
....................    // Calculate Directory Entry offset according to Directory Entry number 
....................    unsigned int16 offset; 
....................    unsigned int16 i; 
....................     
....................    offset = (unsigned int16)num * DIRENTRY_SIZE; 
*
0DF2:  MOVLB  2
0DF4:  CLRF   xC6
0DF6:  RLCF   xC0,W
0DF8:  MOVWF  xC1
0DFA:  RLCF   xC6,W
0DFC:  MOVWF  xC2
0DFE:  RLCF   xC1,F
0E00:  RLCF   xC2,F
0E02:  RLCF   xC1,F
0E04:  RLCF   xC2,F
0E06:  RLCF   xC1,F
0E08:  RLCF   xC2,F
0E0A:  RLCF   xC1,F
0E0C:  RLCF   xC2,F
0E0E:  MOVLW  E0
0E10:  ANDWF  xC1,F
....................    // Copy the Directory Entry data to the DirEntry vector in order to 
....................    // analyze the data later 
....................    for (i = 0; i < DIRENTRY_SIZE; i++) 
0E12:  CLRF   xC4
0E14:  CLRF   xC3
0E16:  MOVF   xC4,F
0E18:  BNZ   0E5C
0E1A:  MOVF   xC3,W
0E1C:  SUBLW  1F
0E1E:  BNC   0E5C
....................    { 
....................        DirEntry[i] = SectorBuffer[offset + i]; 
0E20:  MOVLW  05
0E22:  ADDWF  xC3,W
0E24:  MOVWF  01
0E26:  MOVLW  02
0E28:  ADDWFC xC4,W
0E2A:  MOVWF  03
0E2C:  MOVF   xC3,W
0E2E:  ADDWF  xC1,W
0E30:  MOVWF  xC7
0E32:  MOVF   xC4,W
0E34:  ADDWFC xC2,W
0E36:  MOVWF  xC8
0E38:  MOVLW  05
0E3A:  ADDWF  xC7,W
0E3C:  MOVWF  FE9
0E3E:  MOVLW  00
0E40:  ADDWFC xC8,W
0E42:  MOVWF  FEA
0E44:  MOVFF  FEF,2C9
0E48:  MOVFF  03,FEA
0E4C:  MOVFF  01,FE9
0E50:  MOVFF  2C9,FEF
....................    } 
0E54:  INCF   xC3,F
0E56:  BTFSC  FD8.2
0E58:  INCF   xC4,F
0E5A:  BRA    0E16
.................... } 
0E5C:  MOVLB  0
0E5E:  GOTO   1234 (RETURN)
....................  
.................... BOOLEAN GetEntry(unsigned int16 startingPos) 
.................... { 
....................    pEntry.IsValid = FALSE; 
*
076E:  MOVLB  2
0770:  BCF    x5C.0
....................  
....................    //Partition must exists and be ACTIVE 
....................    if (SectorBuffer[startingPos] != 0x80) 
0772:  MOVLW  05
0774:  ADDWF  xA3,W
0776:  MOVWF  FE9
0778:  MOVLW  00
077A:  ADDWFC xA4,W
077C:  MOVWF  FEA
077E:  MOVF   FEF,W
0780:  SUBLW  80
0782:  BZ    078A
....................       return FALSE; 
0784:  MOVLW  00
0786:  MOVWF  01
0788:  BRA    085A
....................        
....................    pEntry.Type = SectorBuffer[startingPos + 4]; 
078A:  MOVLW  04
078C:  ADDWF  xA3,W
078E:  MOVWF  xA5
0790:  MOVLW  00
0792:  ADDWFC xA4,W
0794:  MOVWF  xA6
0796:  MOVLW  05
0798:  ADDWF  xA5,W
079A:  MOVWF  FE9
079C:  MOVLW  00
079E:  ADDWFC xA6,W
07A0:  MOVWF  FEA
07A2:  MOVFF  FEF,25D
....................     
....................    if (pEntry.Type == 0x04 || pEntry.Type == 0x06 || pEntry.Type == 0x0E) 
07A6:  MOVF   x5D,W
07A8:  SUBLW  04
07AA:  BZ    07B8
07AC:  MOVF   x5D,W
07AE:  SUBLW  06
07B0:  BZ    07B8
07B2:  MOVF   x5D,W
07B4:  SUBLW  0E
07B6:  BNZ   07BC
....................    { 
....................       pEntry.IsFAT32 = FALSE; 
07B8:  BCF    x5C.1
....................       pEntry.IsValid = TRUE; 
07BA:  BSF    x5C.0
....................    } 
....................     
....................    if (pEntry.Type == 0x0B || pEntry.Type == 0x0C) 
07BC:  MOVF   x5D,W
07BE:  SUBLW  0B
07C0:  BZ    07C8
07C2:  MOVF   x5D,W
07C4:  SUBLW  0C
07C6:  BNZ   07CC
....................    { 
....................       pEntry.IsFAT32 = TRUE; 
07C8:  BSF    x5C.1
....................       pEntry.IsValid = TRUE; 
07CA:  BSF    x5C.0
....................    } 
....................     
....................    if (!pEntry.IsValid) 
07CC:  BTFSC  x5C.0
07CE:  BRA    07D6
....................       return FALSE; 
07D0:  MOVLW  00
07D2:  MOVWF  01
07D4:  BRA    085A
....................  
....................    PartitionLBABegin = MAKE32(SectorBuffer[startingPos + 11], SectorBuffer[startingPos + 10], SectorBuffer[startingPos + 9], SectorBuffer[startingPos + 8]); 
07D6:  MOVLW  0B
07D8:  ADDWF  xA3,W
07DA:  MOVWF  xA5
07DC:  MOVLW  00
07DE:  ADDWFC xA4,W
07E0:  MOVWF  xA6
07E2:  MOVLW  05
07E4:  ADDWF  xA5,W
07E6:  MOVWF  FE9
07E8:  MOVLW  00
07EA:  ADDWFC xA6,W
07EC:  MOVWF  FEA
07EE:  MOVFF  FEF,2A7
07F2:  MOVLW  0A
07F4:  ADDWF  xA3,W
07F6:  MOVWF  xA8
07F8:  MOVLW  00
07FA:  ADDWFC xA4,W
07FC:  MOVWF  xA9
07FE:  MOVLW  05
0800:  ADDWF  xA8,W
0802:  MOVWF  FE9
0804:  MOVLW  00
0806:  ADDWFC xA9,W
0808:  MOVWF  FEA
080A:  MOVFF  FEF,2AA
080E:  MOVLW  09
0810:  ADDWF  xA3,W
0812:  MOVWF  xAB
0814:  MOVLW  00
0816:  ADDWFC xA4,W
0818:  MOVWF  xAC
081A:  MOVLW  05
081C:  ADDWF  xAB,W
081E:  MOVWF  FE9
0820:  MOVLW  00
0822:  ADDWFC xAC,W
0824:  MOVWF  FEA
0826:  MOVFF  FEF,2AD
082A:  MOVLW  08
082C:  ADDWF  xA3,W
082E:  MOVWF  xAE
0830:  MOVLW  00
0832:  ADDWFC xA4,W
0834:  MOVWF  xAF
0836:  MOVLW  05
0838:  ADDWF  xAE,W
083A:  MOVWF  FE9
083C:  MOVLW  00
083E:  ADDWFC xAF,W
0840:  MOVWF  FEA
0842:  MOVFF  FEF,2B0
0846:  MOVFF  2A7,236
084A:  MOVFF  2AA,235
084E:  MOVFF  2AD,234
0852:  MOVFF  2B0,233
....................     
....................    return TRUE; 
0856:  MOVLW  01
0858:  MOVWF  01
.................... } 
085A:  MOVLB  0
085C:  GOTO   08AC (RETURN)
....................  
.................... BOOLEAN FindFirstFATPartition() 
.................... { 
....................    BYTE i; 
....................  
....................    // Read the first Sector 
....................    ReadSector(0); 
0860:  MOVLB  3
0862:  CLRF   x01
0864:  CLRF   x00
0866:  MOVLB  2
0868:  CLRF   xFF
086A:  CLRF   xFE
086C:  MOVLB  0
086E:  RCALL  0714
....................  
....................    if (SectorBuffer[0x1FE] != 0x55 || SectorBuffer[0x1FF] != 0xAA) return FALSE;    //If no correct signature, return  
0870:  MOVLB  2
0872:  MOVF   x03,W
0874:  SUBLW  55
0876:  BNZ   087E
0878:  MOVF   x04,W
087A:  SUBLW  AA
087C:  BZ    0884
087E:  MOVLW  00
0880:  MOVWF  01
0882:  BRA    08D0
....................     
....................    pEntry.IsValid = FALSE; 
0884:  BCF    x5C.0
....................    for (i = 0; i < 4; i++) 
0886:  CLRF   xA0
0888:  MOVF   xA0,W
088A:  SUBLW  03
088C:  BNC   08BC
....................    { 
....................       if (GetEntry(FIRST_PARTITION_ENTRY + (i * PARTITION_ENTRY_SIZE))) 
088E:  MOVF   xA0,W
0890:  MULLW  10
0892:  MOVF   FF3,W
0894:  ADDLW  BE
0896:  MOVWF  xA1
0898:  MOVLW  01
089A:  MOVWF  xA2
089C:  BTFSC  FD8.0
089E:  INCF   xA2,F
08A0:  MOVFF  2A2,2A4
08A4:  MOVFF  2A1,2A3
08A8:  MOVLB  0
08AA:  BRA    076E
08AC:  MOVF   01,F
08AE:  BZ    08B6
....................          break; 
08B0:  MOVLB  2
08B2:  BRA    08BC
08B4:  MOVLB  0
....................    } 
08B6:  MOVLB  2
08B8:  INCF   xA0,F
08BA:  BRA    0888
....................     
....................    //Worst case. No partitions entry. Asume that MBR is at Sector 0 and its a FAT32 image. 
....................    if (!pEntry.IsValid) 
08BC:  BTFSC  x5C.0
08BE:  BRA    08CC
....................    { 
....................       // Look for the offset 
....................       PartitionLBABegin = 0; 
08C0:  CLRF   x36
08C2:  CLRF   x35
08C4:  CLRF   x34
08C6:  CLRF   x33
....................       pEntry.IsFAT32 = TRUE; 
08C8:  BSF    x5C.1
....................       pEntry.IsValid = TRUE; 
08CA:  BSF    x5C.0
....................    } 
....................  
....................    return TRUE; 
08CC:  MOVLW  01
08CE:  MOVWF  01
.................... } 
08D0:  MOVLB  0
08D2:  GOTO   16D2 (RETURN)
....................  
.................... BOOLEAN ReadVolumeID() 
.................... {         
....................    // Read the first sector of the partition 
....................    ReadSector(PartitionLBABegin); 
*
0A74:  MOVFF  236,301
0A78:  MOVFF  235,300
0A7C:  MOVFF  234,2FF
0A80:  MOVFF  233,2FE
0A84:  RCALL  0714
....................  
....................    //Initial values 
....................    FAT16Offset = 0; 
0A86:  MOVLB  2
0A88:  CLRF   x3F
....................  
....................    // If the signature is 0xAA55 we are in presence of a FAT volume 
....................    if (SectorBuffer[0x1FE] != 0x55 || SectorBuffer[0x1FF] != 0xAA) return FALSE;    //If no correct signature, return  
0A8A:  MOVF   x03,W
0A8C:  SUBLW  55
0A8E:  BNZ   0A96
0A90:  MOVF   x04,W
0A92:  SUBLW  AA
0A94:  BZ    0A9C
0A96:  MOVLW  00
0A98:  MOVWF  01
0A9A:  BRA    0BD6
....................         
....................    // Bytes per Sector 
....................    BytesPerSector = MAKE16(SectorBuffer[0x0B + 1],SectorBuffer[0x0B]); 
0A9C:  MOVFF  11,226
0AA0:  MOVFF  10,225
....................  
....................    // Sectors per Cluster 
....................    SectorsPerCluster = SectorBuffer[0x0D]; 
0AA4:  MOVFF  12,227
....................  
....................    // Number of Reserved Sectors 
....................    NumberOfReservedSectors = Make16(SectorBuffer[0x0E + 1],SectorBuffer[0x0E]); 
0AA8:  MOVFF  14,229
0AAC:  MOVFF  13,228
....................  
....................    // Number of FATs 
....................    NumberOfFATs = SectorBuffer[0x10]; 
0AB0:  MOVFF  15,22A
....................  
....................    // Sectors per FAT    //differents in FAT16/32 
....................    if (pEntry.IsFAT32) 
0AB4:  BTFSS  x5C.1
0AB6:  BRA    0ACA
....................    { 
....................       SectorsPerFAT = MAKE32(SectorBuffer[0x24+3], SectorBuffer[0x24 + 2], SectorBuffer[0x24 + 1], SectorBuffer[0x24]); 
0AB8:  MOVFF  2C,22E
0ABC:  MOVFF  2B,22D
0AC0:  MOVFF  2A,22C
0AC4:  MOVFF  29,22B
....................    } else { 
0AC8:  BRA    0B5C
....................       SectorsPerFAT = MAKE16(SectorBuffer[0x16 + 1], SectorBuffer[0x16]); 
0ACA:  MOVFF  1C,22C
0ACE:  MOVFF  1B,22B
0AD2:  CLRF   x2D
0AD4:  CLRF   x2E
....................       // FAT16 have an offset to calculate real ClusterBeginLBA 
....................       FAT16Offset = ((unsigned int32)MAKE16(SectorBuffer[0x11 + 1], SectorBuffer[0x11]) * 32) / ((unsigned int32)BytesPerSector); 
0AD6:  MOVFF  17,2A1
0ADA:  MOVFF  16,2A0
0ADE:  CLRF   xA2
0AE0:  CLRF   xA3
0AE2:  RLCF   16,W
0AE4:  MOVWF  xA4
0AE6:  RLCF   17,W
0AE8:  MOVWF  xA5
0AEA:  RLCF   xA2,W
0AEC:  MOVWF  xA6
0AEE:  RLCF   xA3,W
0AF0:  MOVWF  xA7
0AF2:  RLCF   xA4,F
0AF4:  RLCF   xA5,F
0AF6:  RLCF   xA6,F
0AF8:  RLCF   xA7,F
0AFA:  RLCF   xA4,F
0AFC:  RLCF   xA5,F
0AFE:  RLCF   xA6,F
0B00:  RLCF   xA7,F
0B02:  RLCF   xA4,F
0B04:  RLCF   xA5,F
0B06:  RLCF   xA6,F
0B08:  RLCF   xA7,F
0B0A:  RLCF   xA4,F
0B0C:  RLCF   xA5,F
0B0E:  RLCF   xA6,F
0B10:  RLCF   xA7,F
0B12:  MOVLW  E0
0B14:  ANDWF  xA4,F
0B16:  MOVFF  225,00
0B1A:  MOVFF  226,01
0B1E:  CLRF   02
0B20:  CLRF   03
0B22:  MOVFF  03,2AB
0B26:  MOVFF  02,2AA
0B2A:  MOVFF  226,2A9
0B2E:  MOVFF  225,2A8
0B32:  MOVFF  2A7,309
0B36:  MOVFF  2A6,308
0B3A:  MOVFF  2A5,307
0B3E:  MOVFF  2A4,306
0B42:  MOVFF  03,30D
0B46:  MOVFF  02,30C
0B4A:  MOVFF  226,30B
0B4E:  MOVFF  225,30A
0B52:  MOVLB  0
0B54:  RCALL  08D6
0B56:  MOVFF  00,23F
0B5A:  MOVLB  2
....................    } 
....................  
....................    // Important zones CALCULUS: 
....................    FatBeginLBA = PartitionLBABegin + ((unsigned int32)NumberOfReservedSectors); 
0B5C:  CLRF   02
0B5E:  CLRF   03
0B60:  MOVF   x28,W
0B62:  ADDWF  x33,W
0B64:  MOVWF  x37
0B66:  MOVF   x29,W
0B68:  ADDWFC x34,W
0B6A:  MOVWF  x38
0B6C:  MOVF   02,W
0B6E:  ADDWFC x35,W
0B70:  MOVWF  x39
0B72:  MOVF   03,W
0B74:  ADDWFC x36,W
0B76:  MOVWF  x3A
....................    DataBeginLBA = FatBeginLBA + ((unsigned int32)(NumberOfFATs * SectorsPerFAT)); 
0B78:  MOVLB  3
0B7A:  CLRF   x09
0B7C:  CLRF   x08
0B7E:  CLRF   x07
0B80:  MOVFF  22A,306
0B84:  MOVFF  22E,30D
0B88:  MOVFF  22D,30C
0B8C:  MOVFF  22C,30B
0B90:  MOVFF  22B,30A
0B94:  MOVLB  0
0B96:  RCALL  0A18
0B98:  MOVF   00,W
0B9A:  MOVLB  2
0B9C:  ADDWF  x37,W
0B9E:  MOVWF  x3B
0BA0:  MOVF   01,W
0BA2:  ADDWFC x38,W
0BA4:  MOVWF  x3C
0BA6:  MOVF   02,W
0BA8:  ADDWFC x39,W
0BAA:  MOVWF  x3D
0BAC:  MOVF   03,W
0BAE:  ADDWFC x3A,W
0BB0:  MOVWF  x3E
....................  
....................    // Root Directory First Cluster 
....................    if (pEntry.IsFAT32) 
0BB2:  BTFSS  x5C.1
0BB4:  BRA    0BC8
....................    { 
....................       RootDirectoryFirstCluster = MAKE32(SectorBuffer[0x2C + 3], SectorBuffer[0x2C + 2], SectorBuffer[0x2C + 1], SectorBuffer[0x2C]);   
0BB6:  MOVFF  34,232
0BBA:  MOVFF  33,231
0BBE:  MOVFF  32,230
0BC2:  MOVFF  31,22F
....................    } else { 
0BC6:  BRA    0BD2
....................       //DataBeginLBA += 32; 
....................       RootDirectoryFirstCluster = 2; 
0BC8:  CLRF   x32
0BCA:  CLRF   x31
0BCC:  CLRF   x30
0BCE:  MOVLW  02
0BD0:  MOVWF  x2F
....................    } 
....................     
....................    return TRUE; 
0BD2:  MOVLW  01
0BD4:  MOVWF  01
.................... } 
0BD6:  MOVLB  0
0BD8:  GOTO   179A (RETURN)
....................  
.................... unsigned int32 ComputeLBA(unsigned int32 clusternumber) 
.................... { 
....................    // Compute the LBA number using the Cluster Number{ 
....................    return DataBeginLBA + ((clusternumber - 2) * ((unsigned int32)SectorsPerCluster)); 
*
0D40:  MOVLW  02
0D42:  MOVLB  2
0D44:  SUBWF  xEA,W
0D46:  MOVWF  xEE
0D48:  MOVLW  00
0D4A:  SUBWFB xEB,W
0D4C:  MOVWF  xEF
0D4E:  MOVLW  00
0D50:  SUBWFB xEC,W
0D52:  MOVWF  xF0
0D54:  MOVLW  00
0D56:  SUBWFB xED,W
0D58:  MOVWF  xF1
0D5A:  MOVFF  227,00
0D5E:  CLRF   01
0D60:  CLRF   02
0D62:  CLRF   03
0D64:  MOVFF  03,2F5
0D68:  MOVFF  02,2F4
0D6C:  MOVFF  01,2F3
0D70:  MOVFF  227,2F2
0D74:  MOVFF  FE8,309
0D78:  MOVFF  2F0,308
0D7C:  MOVFF  2EF,307
0D80:  MOVFF  2EE,306
0D84:  MOVFF  03,30D
0D88:  MOVFF  02,30C
0D8C:  MOVFF  01,30B
0D90:  MOVFF  227,30A
0D94:  MOVLB  0
0D96:  RCALL  0A18
0D98:  MOVLB  2
0D9A:  MOVF   x3B,W
0D9C:  ADDWF  00,F
0D9E:  MOVF   x3C,W
0DA0:  ADDWFC 01,F
0DA2:  MOVF   x3D,W
0DA4:  ADDWFC 02,F
0DA6:  MOVF   x3E,W
0DA8:  ADDWFC 03,F
.................... } 
0DAA:  MOVLB  0
0DAC:  RETLW  00
....................  
.................... BOOLEAN CheckIfEOD() 
.................... { 
....................    // Check if the current directory entry (contained in the DirEntry vector) 
....................    // correspond to the flag End Of Directory. 
....................    if (DirEntry[0] == 0x00) 
*
0E62:  MOVLB  2
0E64:  MOVF   x05,F
0E66:  BNZ   0E70
....................    { 
....................        return TRUE; 
0E68:  MOVLW  01
0E6A:  MOVWF  01
0E6C:  BRA    0E76
....................    } 
....................    else 
0E6E:  BRA    0E76
....................    { 
....................        return FALSE; 
0E70:  MOVLW  00
0E72:  MOVWF  01
0E74:  BRA    0E76
....................    } 
.................... } 
0E76:  MOVLB  0
0E78:  RETLW  00
....................  
.................... BYTE GetAttib() 
.................... { 
....................    // Get the Attributes byte from current Directory Entry 
....................    return DirEntry[0x0B]; 
0E7A:  MOVLB  2
0E7C:  MOVFF  210,01
.................... } 
0E80:  MOVLB  0
0E82:  RETLW  00
....................  
.................... BOOLEAN CheckIfNormalFile() 
.................... { 
....................    // Check if the Directory Entry corresponds to a Normal File Name 
....................    BYTE attr; 
....................     
....................    attr = GetAttib(); 
0E84:  RCALL  0E7A
0E86:  MOVFF  01,2C0
....................  
....................    attr <<= 4; 
0E8A:  MOVLB  2
0E8C:  SWAPF  xC0,F
0E8E:  MOVLW  F0
0E90:  ANDWF  xC0,F
....................    if (attr == 0xF0) 
0E92:  MOVF   xC0,W
0E94:  SUBLW  F0
0E96:  BNZ   0EA0
....................    { 
....................        // If not, it is a Long File Name entry 
....................        return FALSE; 
0E98:  MOVLW  00
0E9A:  MOVWF  01
0E9C:  BRA    0EA6
....................    } 
....................    else 
0E9E:  BRA    0EA6
....................    { 
....................        return TRUE; 
0EA0:  MOVLW  01
0EA2:  MOVWF  01
0EA4:  BRA    0EA6
....................    } 
.................... } 
0EA6:  MOVLB  0
0EA8:  GOTO   0ED4 (RETURN)
....................  
.................... BYTE DetermineDirEntryType() 
.................... { 
....................    // Determine the Directory Entry type 
....................    if (CheckIfEOD()) 
0EAC:  RCALL  0E62
0EAE:  MOVF   01,F
0EB0:  BZ    0EC0
....................    { 
....................        // The Directory Entry is an End Of Directory flag 
....................        EODReached = TRUE; 
0EB2:  MOVLB  2
0EB4:  BSF    x4B.1
....................        return EOD; 
0EB6:  MOVLW  00
0EB8:  MOVWF  01
0EBA:  BRA    0EFC
....................    } 
....................    else 
0EBC:  BRA    0EFC
0EBE:  MOVLB  0
....................    { 
....................        // If not, we check the first byte to know if the entry is unused 
....................        if (DirEntry[0] == 0xE5) 
0EC0:  MOVLB  2
0EC2:  MOVF   x05,W
0EC4:  SUBLW  E5
0EC6:  BNZ   0ED0
....................        { 
....................            return UNUSED; 
0EC8:  MOVLW  01
0ECA:  MOVWF  01
0ECC:  BRA    0EFC
....................        } 
....................        else 
0ECE:  BRA    0EFC
....................        { 
....................            // If it is used, we check if the Directory Entry corresponds to a Normal File Name 
....................            if (CheckIfNormalFile()) 
0ED0:  MOVLB  0
0ED2:  BRA    0E84
0ED4:  MOVF   01,F
0ED6:  BZ    0EF4
....................            { 
....................                if(bit_test(GetAttib(),4)) return NDNAME;       //is a sub directory. 
0ED8:  RCALL  0E7A
0EDA:  MOVFF  01,2C0
0EDE:  MOVLB  2
0EE0:  BTFSS  01.4
0EE2:  BRA    0EEA
0EE4:  MOVLW  04
0EE6:  MOVWF  01
0EE8:  BRA    0EFC
....................                return NFNAME; 
0EEA:  MOVLW  03
0EEC:  MOVWF  01
0EEE:  BRA    0EFC
....................            } 
....................            else 
0EF0:  BRA    0EFC
0EF2:  MOVLB  0
....................            { 
....................                return LFNAME; 
0EF4:  MOVLW  02
0EF6:  MOVWF  01
0EF8:  MOVLB  2
0EFA:  BRA    0EFC
....................            } 
....................        } 
....................    } 
.................... } 
0EFC:  MOVLB  0
0EFE:  GOTO   1236 (RETURN)
....................  
.................... unsigned int32 GetFileSize() 
.................... { 
....................    // Get the file size of the current Directory Entry 
....................    return MAKE32(DirEntry[0x1C + 3], DirEntry[0x1C + 2], DirEntry[0x1C + 1], DirEntry[0x1C + 0]); 
*
0FF6:  MOVFF  224,03
0FFA:  MOVFF  223,02
0FFE:  MOVFF  222,01
1002:  MOVFF  221,00
.................... } 
1006:  GOTO   12B2 (RETURN)
....................  
.................... void GetFileName(BYTE * filename) 
.................... { 
....................    // Get the 8+3 FAT32 short file name. 
....................    // This function may be changed in other platforms and/or architectures 
....................    // using the correct string functions. 
....................    unsigned int8 i; 
....................     
....................    for (i = 0; i < 8; i++) 
*
0F66:  MOVLB  2
0F68:  CLRF   xC2
0F6A:  MOVF   xC2,W
0F6C:  SUBLW  07
0F6E:  BNC   0FA2
....................    { 
....................        filename[i] = DirEntry[i]; 
0F70:  CLRF   03
0F72:  MOVF   xC2,W
0F74:  ADDWF  xC0,W
0F76:  MOVWF  01
0F78:  MOVF   xC1,W
0F7A:  ADDWFC 03,F
0F7C:  MOVFF  03,2C4
0F80:  CLRF   03
0F82:  MOVF   xC2,W
0F84:  ADDLW  05
0F86:  MOVWF  FE9
0F88:  MOVLW  02
0F8A:  ADDWFC 03,W
0F8C:  MOVWF  FEA
0F8E:  MOVFF  FEF,2C5
0F92:  MOVFF  2C4,FEA
0F96:  MOVFF  01,FE9
0F9A:  MOVFF  2C5,FEF
....................    } 
0F9E:  INCF   xC2,F
0FA0:  BRA    0F6A
....................    filename[8] = '.'; 
0FA2:  MOVLW  08
0FA4:  ADDWF  xC0,W
0FA6:  MOVWF  FE9
0FA8:  MOVLW  00
0FAA:  ADDWFC xC1,W
0FAC:  MOVWF  FEA
0FAE:  MOVLW  2E
0FB0:  MOVWF  FEF
....................    for (i = 8; i < 11; i++) 
0FB2:  MOVLW  08
0FB4:  MOVWF  xC2
0FB6:  MOVF   xC2,W
0FB8:  SUBLW  0A
0FBA:  BNC   0FF0
....................    { 
....................        filename[i + 1] = DirEntry[i]; 
0FBC:  MOVLW  01
0FBE:  ADDWF  xC2,W
0FC0:  CLRF   03
0FC2:  ADDWF  xC0,W
0FC4:  MOVWF  01
0FC6:  MOVF   xC1,W
0FC8:  ADDWFC 03,F
0FCA:  MOVFF  03,2C5
0FCE:  CLRF   03
0FD0:  MOVF   xC2,W
0FD2:  ADDLW  05
0FD4:  MOVWF  FE9
0FD6:  MOVLW  02
0FD8:  ADDWFC 03,W
0FDA:  MOVWF  FEA
0FDC:  MOVFF  FEF,2C6
0FE0:  MOVFF  2C5,FEA
0FE4:  MOVFF  01,FE9
0FE8:  MOVFF  2C6,FEF
....................    } 
0FEC:  INCF   xC2,F
0FEE:  BRA    0FB6
....................     
.................... } 
0FF0:  MOVLB  0
0FF2:  GOTO   12B0 (RETURN)
....................  
.................... void GetDirName(BYTE * filename) 
.................... { 
....................    // Get the 8 FAT32 short file name. 
....................    // This function may be changed in other platforms and/or architectures 
....................    // using the correct string functions. 
....................    unsigned int8 i; 
....................     
....................    for (i = 0; i < 11; i++) 
*
0F02:  MOVLB  2
0F04:  CLRF   xC2
0F06:  MOVF   xC2,W
0F08:  SUBLW  0A
0F0A:  BNC   0F3E
....................    { 
....................        filename[i] = DirEntry[i]; 
0F0C:  CLRF   03
0F0E:  MOVF   xC2,W
0F10:  ADDWF  xC0,W
0F12:  MOVWF  01
0F14:  MOVF   xC1,W
0F16:  ADDWFC 03,F
0F18:  MOVFF  03,2C4
0F1C:  CLRF   03
0F1E:  MOVF   xC2,W
0F20:  ADDLW  05
0F22:  MOVWF  FE9
0F24:  MOVLW  02
0F26:  ADDWFC 03,W
0F28:  MOVWF  FEA
0F2A:  MOVFF  FEF,2C5
0F2E:  MOVFF  2C4,FEA
0F32:  MOVFF  01,FE9
0F36:  MOVFF  2C5,FEF
....................    } 
0F3A:  INCF   xC2,F
0F3C:  BRA    0F06
....................  
....................    filename[i]='\0'; 
0F3E:  CLRF   03
0F40:  MOVF   xC2,W
0F42:  ADDWF  xC0,W
0F44:  MOVWF  FE9
0F46:  MOVF   xC1,W
0F48:  ADDWFC 03,W
0F4A:  MOVWF  FEA
0F4C:  CLRF   FEF
....................  
.................... } 
0F4E:  MOVLB  0
0F50:  GOTO   1250 (RETURN)
....................  
.................... unsigned int32 GetFileFirstCluster() 
.................... { 
....................    // Get the file first cluster using the current Directory Entry data 
....................    return MAKE32(DirEntry[0x14 + 1], DirEntry[0x14], DirEntry[0x1A + 1], DirEntry[0x1A]); 
0F54:  MOVFF  21A,03
0F58:  MOVFF  219,02
0F5C:  MOVFF  220,01
0F60:  MOVFF  21F,00
.................... } 
0F64:  RETLW  00
....................  
.................... unsigned int32 ReadFAT(unsigned int32 clusternumber) 
.................... { 
....................    // This might be one of the most complicated functions in the entire FAT16/32 
....................    // implementation. It computes the next cluster of a file/directory reading the 
....................    // FAT table. 
....................  
....................    // Calculate the sector number (after FAT LBA Begin) in which we can find 
....................    // the cluster information we are looking for. 
....................     
....................    unsigned int32 calc; 
....................    unsigned int32 offset; 
....................    unsigned int32 rest; 
....................    unsigned int32 soff; 
....................     
....................    calc = clusternumber / ((unsigned int32)BytesPerSector / 4); 
*
100A:  MOVLB  3
100C:  CLRF   x01
100E:  CLRF   x00
1010:  MOVFF  226,2FF
1014:  MOVFF  225,2FE
1018:  RRCF   x01,W
101A:  MOVWF  03
101C:  RRCF   x00,W
101E:  MOVWF  02
1020:  MOVLB  2
1022:  RRCF   x26,W
1024:  MOVWF  01
1026:  RRCF   x25,W
1028:  MOVWF  00
102A:  RRCF   03,F
102C:  RRCF   02,F
102E:  RRCF   01,F
1030:  RRCF   00,F
1032:  MOVLW  3F
1034:  ANDWF  03,F
1036:  MOVFF  03,305
103A:  MOVFF  02,304
103E:  MOVFF  01,303
1042:  MOVFF  00,302
1046:  MOVFF  2ED,309
104A:  MOVFF  2EC,308
104E:  MOVFF  2EB,307
1052:  MOVFF  2EA,306
1056:  MOVFF  03,30D
105A:  MOVFF  02,30C
105E:  MOVFF  01,30B
1062:  MOVFF  00,30A
1066:  MOVLB  0
1068:  RCALL  08D6
106A:  MOVFF  03,2F1
106E:  MOVFF  02,2F0
1072:  MOVFF  01,2EF
1076:  MOVFF  00,2EE
....................  
....................    // Calculate the LBA of the sector containing the information 
....................    offset = FatBeginLBA + calc; 
107A:  MOVLB  2
107C:  MOVF   xEE,W
107E:  ADDWF  x37,W
1080:  MOVWF  xF2
1082:  MOVF   xEF,W
1084:  ADDWFC x38,W
1086:  MOVWF  xF3
1088:  MOVF   xF0,W
108A:  ADDWFC x39,W
108C:  MOVWF  xF4
108E:  MOVF   xF1,W
1090:  ADDWFC x3A,W
1092:  MOVWF  xF5
....................  
....................    // Calculate the offset within the sector that has been read 
....................    rest = clusternumber - (calc * ((unsigned int32)BytesPerSector / 4)); 
1094:  MOVLB  3
1096:  CLRF   x01
1098:  CLRF   x00
109A:  MOVFF  226,2FF
109E:  MOVFF  225,2FE
10A2:  RRCF   x01,W
10A4:  MOVWF  03
10A6:  RRCF   x00,W
10A8:  MOVWF  02
10AA:  MOVLB  2
10AC:  RRCF   x26,W
10AE:  MOVWF  01
10B0:  RRCF   x25,W
10B2:  MOVWF  00
10B4:  RRCF   03,F
10B6:  RRCF   02,F
10B8:  RRCF   01,F
10BA:  RRCF   00,F
10BC:  MOVLW  3F
10BE:  ANDWF  03,F
10C0:  MOVFF  03,305
10C4:  MOVFF  02,304
10C8:  MOVFF  01,303
10CC:  MOVFF  00,302
10D0:  MOVFF  2F1,309
10D4:  MOVFF  2F0,308
10D8:  MOVFF  2EF,307
10DC:  MOVFF  2EE,306
10E0:  MOVFF  03,30D
10E4:  MOVFF  02,30C
10E8:  MOVFF  01,30B
10EC:  MOVFF  00,30A
10F0:  MOVLB  0
10F2:  RCALL  0A18
10F4:  MOVF   00,W
10F6:  MOVLB  2
10F8:  SUBWF  xEA,W
10FA:  MOVWF  xF6
10FC:  MOVF   01,W
10FE:  SUBWFB xEB,W
1100:  MOVWF  xF7
1102:  MOVF   02,W
1104:  SUBWFB xEC,W
1106:  MOVWF  xF8
1108:  MOVF   03,W
110A:  SUBWFB xED,W
110C:  MOVWF  xF9
....................    soff = rest * 4; 
110E:  RLCF   xF6,W
1110:  MOVWF  xFA
1112:  RLCF   xF7,W
1114:  MOVWF  xFB
1116:  RLCF   xF8,W
1118:  MOVWF  xFC
111A:  RLCF   xF9,W
111C:  MOVWF  xFD
111E:  RLCF   xFA,F
1120:  RLCF   xFB,F
1122:  RLCF   xFC,F
1124:  RLCF   xFD,F
1126:  MOVLW  FC
1128:  ANDWF  xFA,F
....................  
....................    // Read the sector 
....................    ReadSector(offset); 
112A:  MOVFF  2F5,301
112E:  MOVFF  2F4,300
1132:  MOVFF  2F3,2FF
1136:  MOVFF  2F2,2FE
113A:  MOVLB  0
113C:  CALL   0714
....................    // Read the next cluster number 
....................    return MAKE32(SectorBuffer[soff + 3], SectorBuffer[soff + 2], SectorBuffer[soff + 1], SectorBuffer[soff]); 
1140:  MOVLW  03
1142:  MOVLB  2
1144:  ADDWF  xFA,W
1146:  MOVWF  xFE
1148:  MOVLW  00
114A:  ADDWFC xFB,W
114C:  MOVWF  xFF
114E:  MOVLW  00
1150:  ADDWFC xFC,W
1152:  MOVLW  00
1154:  MOVLB  2
1156:  ADDWFC xFD,W
1158:  MOVLW  05
115A:  MOVLB  2
115C:  ADDWF  xFE,W
115E:  MOVWF  FE9
1160:  MOVLW  00
1162:  ADDWFC xFF,W
1164:  MOVWF  FEA
1166:  MOVFF  FEF,302
116A:  MOVLW  02
116C:  ADDWF  xFA,W
116E:  MOVLB  3
1170:  MOVWF  x03
1172:  MOVLW  00
1174:  MOVLB  2
1176:  ADDWFC xFB,W
1178:  MOVLB  3
117A:  MOVWF  x04
117C:  MOVLW  00
117E:  MOVLB  2
1180:  ADDWFC xFC,W
1182:  MOVLW  00
1184:  MOVLB  2
1186:  ADDWFC xFD,W
1188:  MOVLB  3
118A:  MOVLW  05
118C:  ADDWF  x03,W
118E:  MOVWF  FE9
1190:  MOVLW  00
1192:  ADDWFC x04,W
1194:  MOVWF  FEA
1196:  MOVFF  FEF,307
119A:  MOVLW  01
119C:  MOVLB  2
119E:  ADDWF  xFA,W
11A0:  MOVLB  3
11A2:  MOVWF  x08
11A4:  MOVLW  00
11A6:  MOVLB  2
11A8:  ADDWFC xFB,W
11AA:  MOVLB  3
11AC:  MOVWF  x09
11AE:  MOVLW  00
11B0:  MOVLB  2
11B2:  ADDWFC xFC,W
11B4:  MOVLW  00
11B6:  MOVLB  2
11B8:  ADDWFC xFD,W
11BA:  MOVLB  3
11BC:  MOVLW  05
11BE:  ADDWF  x08,W
11C0:  MOVWF  FE9
11C2:  MOVLW  00
11C4:  ADDWFC x09,W
11C6:  MOVWF  FEA
11C8:  MOVFF  FEF,30C
11CC:  MOVLW  05
11CE:  MOVLB  2
11D0:  ADDWF  xFA,W
11D2:  MOVWF  FE9
11D4:  MOVLW  00
11D6:  ADDWFC xFB,W
11D8:  MOVWF  FEA
11DA:  MOVFF  FEF,30D
11DE:  MOVFF  302,03
11E2:  MOVFF  307,02
11E6:  MOVFF  30C,01
11EA:  MOVFF  30D,00
.................... } 
11EE:  MOVLB  0
11F0:  RETLW  00
....................  
.................... void OpenDirectory(unsigned int32 directorycluster) 
.................... { 
....................    // Initialize the variables needed to follow the directory pointed by 
....................    // the passed argument. 
....................    DirectoryCurrentCluster = directorycluster; 
*
0DAE:  MOVFF  2A3,243
0DB2:  MOVFF  2A2,242
0DB6:  MOVFF  2A1,241
0DBA:  MOVFF  2A0,240
....................    DirectoryCurrentLBA = ComputeLBA(DirectoryCurrentCluster); 
0DBE:  MOVFF  243,2ED
0DC2:  MOVFF  242,2EC
0DC6:  MOVFF  241,2EB
0DCA:  MOVFF  240,2EA
0DCE:  RCALL  0D40
0DD0:  MOVFF  03,247
0DD4:  MOVFF  02,246
0DD8:  MOVFF  01,245
0DDC:  MOVFF  00,244
....................    DirectoryCurrentDirEntry = 0; 
0DE0:  MOVLB  2
0DE2:  CLRF   x48
....................    DirectoryCurrentSector = 0; 
0DE4:  CLRF   x4A
0DE6:  CLRF   x49
....................  
....................    EODReached = FALSE; 
0DE8:  BCF    x4B.1
....................    DirectoryOpened = TRUE; 
0DEA:  BSF    x4B.0
.................... } 
0DEC:  MOVLB  0
0DEE:  GOTO   1AD4 (RETURN)
....................  
.................... FILEDESCRIPTOR FindNextFile() 
.................... { 
....................    // Define the variables that will be used 
....................    FILEDESCRIPTOR thefile; 
....................    BOOLEAN filefound; 
....................  
....................    // Set initial values 
....................    filefound = FALSE; 
*
11F2:  MOVLB  2
11F4:  BCF    xBF.0
....................     
....................    thefile.Attributes = 0; 
11F6:  CLRF   xB2
....................    thefile.FirstLBA = 0; 
11F8:  CLRF   xB6
11FA:  CLRF   xB5
11FC:  CLRF   xB4
11FE:  CLRF   xB3
....................    thefile.FirstCluster = 0; 
1200:  CLRF   xBE
1202:  CLRF   xBD
1204:  CLRF   xBC
1206:  CLRF   xBB
....................    thefile.Size = 0; 
1208:  CLRF   xBA
120A:  CLRF   xB9
120C:  CLRF   xB8
120E:  CLRF   xB7
....................  
....................    // Read the next sector of the cluster 
....................    ReadSector(DirectoryCurrentLBA); 
1210:  MOVFF  247,301
1214:  MOVFF  246,300
1218:  MOVFF  245,2FF
121C:  MOVFF  244,2FE
1220:  MOVLB  0
1222:  CALL   0714
....................  
....................    // If the directory has been opened with OpenDirectory 
....................    if (DirectoryOpened) 
1226:  MOVLB  2
1228:  BTFSS  x4B.0
122A:  BRA    13AA
....................    { 
....................        // Follow the Directory Entries looking for files 
....................        do 
....................        { 
....................            // Read the next directory entry 
....................            ReadDirEntry(DirectoryCurrentDirEntry); 
122C:  MOVFF  248,2C0
1230:  MOVLB  0
1232:  BRA    0DF2
....................  
....................             switch (DetermineDirEntryType()) 
....................             { 
1234:  BRA    0EAC
1236:  MOVF   01,W
1238:  XORLW  04
123A:  BZ    1242
123C:  XORLW  07
123E:  BZ    129A
1240:  BRA    130C
....................                // If the directory entry is a Normal Directory Name 
....................                case NDNAME: 
....................                   // We are in presence of a sub directory, and we get its information 
....................                   GetDirName(thefile.Name); 
1242:  MOVLW  02
1244:  MOVLB  2
1246:  MOVWF  xC1
1248:  MOVLW  A6
124A:  MOVWF  xC0
124C:  MOVLB  0
124E:  BRA    0F02
....................                   thefile.Attributes = GetAttib(); 
1250:  RCALL  0E7A
1252:  MOVFF  01,2B2
....................                   thefile.FirstCluster = GetFileFirstCluster(); 
1256:  RCALL  0F54
1258:  MOVFF  03,2BE
125C:  MOVFF  02,2BD
1260:  MOVFF  01,2BC
1264:  MOVFF  00,2BB
....................                   thefile.FirstLBA = ComputeLBA(thefile.FirstCluster) + FAT16Offset; 
1268:  MOVFF  2BE,2ED
126C:  MOVFF  2BD,2EC
1270:  MOVFF  2BC,2EB
1274:  MOVFF  2BB,2EA
1278:  RCALL  0D40
127A:  MOVLB  2
127C:  MOVF   x3F,W
127E:  ADDWF  00,W
1280:  MOVWF  xB3
1282:  MOVLW  00
1284:  ADDWFC 01,W
1286:  MOVWF  xB4
1288:  MOVLW  00
128A:  ADDWFC 02,W
128C:  MOVWF  xB5
128E:  MOVLW  00
1290:  ADDWFC 03,W
1292:  MOVWF  xB6
....................  
....................                   // Read the last computed sector, to re-fill the SectorBuffer 
....................                   // that could have been overwritten when obtaining file information. 
....................                   //ReadSectorRelativeToPartition(DirectoryCurrentLBA);  ???? 
....................  
....................                   // Set the File Found flag 
....................                   filefound = TRUE; 
1294:  BSF    xBF.0
....................                   break; 
1296:  MOVLB  0
1298:  BRA    130C
....................  
....................                // If the directory entry is a Normal File Name 
....................                case NFNAME: 
....................                   // And the Attribute is 0x20 
....................                   if (GetAttib() == 0x20) 
129A:  RCALL  0E7A
129C:  MOVF   01,W
129E:  SUBLW  20
12A0:  BNZ   130A
....................                   { 
....................                      // We are in presence of a file, and we get its information 
....................                      GetFileName(thefile.Name); 
12A2:  MOVLW  02
12A4:  MOVLB  2
12A6:  MOVWF  xC1
12A8:  MOVLW  A6
12AA:  MOVWF  xC0
12AC:  MOVLB  0
12AE:  BRA    0F66
....................                      thefile.Size = GetFileSize(); 
12B0:  BRA    0FF6
12B2:  MOVFF  03,2BA
12B6:  MOVFF  02,2B9
12BA:  MOVFF  01,2B8
12BE:  MOVFF  00,2B7
....................                      thefile.Attributes = GetAttib(); 
12C2:  RCALL  0E7A
12C4:  MOVFF  01,2B2
....................                      thefile.FirstCluster = GetFileFirstCluster(); 
12C8:  RCALL  0F54
12CA:  MOVFF  03,2BE
12CE:  MOVFF  02,2BD
12D2:  MOVFF  01,2BC
12D6:  MOVFF  00,2BB
....................                      thefile.FirstLBA = ComputeLBA(thefile.FirstCluster) + FAT16Offset; 
12DA:  MOVFF  2BE,2ED
12DE:  MOVFF  2BD,2EC
12E2:  MOVFF  2BC,2EB
12E6:  MOVFF  2BB,2EA
12EA:  RCALL  0D40
12EC:  MOVLB  2
12EE:  MOVF   x3F,W
12F0:  ADDWF  00,W
12F2:  MOVWF  xB3
12F4:  MOVLW  00
12F6:  ADDWFC 01,W
12F8:  MOVWF  xB4
12FA:  MOVLW  00
12FC:  ADDWFC 02,W
12FE:  MOVWF  xB5
1300:  MOVLW  00
1302:  ADDWFC 03,W
1304:  MOVWF  xB6
....................                       
....................                      // Read the last computed sector, to re-fill the SectorBuffer 
....................                      // that could have been overwritten when obtaining file information. 
....................                      //ReadSectorRelativeToPartition(DirectoryCurrentLBA);  ????? 
....................                       
....................                      // Set the File Found flag 
....................                      filefound = TRUE; 
1306:  BSF    xBF.0
1308:  MOVLB  0
....................                   }                
....................                   break; 
130A:  BRA    130C
....................             } 
....................           
....................            // Increment the current Directory Entry index 
....................            DirectoryCurrentDirEntry++; 
130C:  MOVLB  2
130E:  INCF   x48,F
....................            // If the Directory Entry index is greater than 15 (only 16 
....................            // directory entries could be found into a sector) 
....................            if (DirectoryCurrentDirEntry > 15) 
1310:  MOVF   x48,W
1312:  SUBLW  0F
1314:  BC    139C
....................            { 
....................                // Reset the Directory Entry index 
....................                DirectoryCurrentDirEntry = 0; 
1316:  CLRF   x48
....................  
....................                // Increment the current sector index 
....................                DirectoryCurrentSector++; 
1318:  INCF   x49,F
131A:  BTFSC  FD8.2
131C:  INCF   x4A,F
....................                // If the sector index is minor than the SectorsPerCluster 
....................                if (DirectoryCurrentSector < SectorsPerCluster) 
131E:  MOVF   x4A,F
1320:  BNZ   133A
1322:  MOVF   x27,W
1324:  SUBWF  x49,W
1326:  BC    133A
....................                { 
....................                    // We move to the next sector 
....................                    DirectoryCurrentLBA++; 
1328:  MOVLW  01
132A:  ADDWF  x44,F
132C:  BTFSC  FD8.0
132E:  INCF   x45,F
1330:  BTFSC  FD8.2
1332:  INCF   x46,F
1334:  BTFSC  FD8.2
1336:  INCF   x47,F
....................                } 
....................                // If not, we need to move to another cluster 
....................                else 
1338:  BRA    1384
....................                { 
....................                    // And we compute the next cluster first sector 
....................                    DirectoryCurrentSector = 0; 
133A:  CLRF   x4A
133C:  CLRF   x49
....................                    DirectoryCurrentCluster = ReadFAT(DirectoryCurrentCluster); 
133E:  MOVFF  243,2ED
1342:  MOVFF  242,2EC
1346:  MOVFF  241,2EB
134A:  MOVFF  240,2EA
134E:  MOVLB  0
1350:  RCALL  100A
1352:  MOVFF  03,243
1356:  MOVFF  02,242
135A:  MOVFF  01,241
135E:  MOVFF  00,240
....................                    DirectoryCurrentLBA = ComputeLBA(DirectoryCurrentCluster); 
1362:  MOVFF  243,2ED
1366:  MOVFF  242,2EC
136A:  MOVFF  241,2EB
136E:  MOVFF  240,2EA
1372:  RCALL  0D40
1374:  MOVFF  03,247
1378:  MOVFF  02,246
137C:  MOVFF  01,245
1380:  MOVFF  00,244
....................                } 
....................  
....................                // Read the next sector computed before 
....................                ReadSector(DirectoryCurrentLBA); 
1384:  MOVFF  247,301
1388:  MOVFF  246,300
138C:  MOVFF  245,2FF
1390:  MOVFF  244,2FE
1394:  MOVLB  0
1396:  CALL   0714
139A:  MOVLB  2
....................            } 
....................        } 
....................        // Do this until an EOD is found or the File Found flag is set 
....................        while ((!CheckIfEOD()) && (!filefound)); 
139C:  MOVLB  0
139E:  RCALL  0E62
13A0:  MOVF   01,F
13A2:  BNZ   13AC
13A4:  MOVLB  2
13A6:  BTFSS  xBF.0
13A8:  BRA    122C
13AA:  MOVLB  0
....................    } 
....................  
....................    // Return the File Descriptor 
....................    return thefile; 
13AC:  MOVLW  A6
13AE:  MOVWF  01
13B0:  MOVLW  02
13B2:  MOVWF  02
.................... } 
13B4:  GOTO   1AD8 (RETURN)
....................  
.................... void CloseDirectory() 
.................... { 
....................    // Close the directory 
....................    DirectoryOpened = FALSE; 
*
161A:  MOVLB  2
161C:  BCF    x4B.0
.................... } 
161E:  MOVLB  0
1620:  GOTO   1FCC (RETURN)
....................  
.................... void OpenFile(FILEDESCRIPTOR file) 
.................... { 
....................    // Initialize the variables needed to follow the file pointed by 
....................    // the passed File Descriptor. 
....................    FileCurrentCluster = file.FirstCluster; 
*
13B8:  MOVFF  2B8,24F
13BC:  MOVFF  2B7,24E
13C0:  MOVFF  2B6,24D
13C4:  MOVFF  2B5,24C
....................    FileCurrentLBA = ComputeLBA(FileCurrentCluster) + FAT16offset; 
13C8:  MOVFF  24F,2ED
13CC:  MOVFF  24E,2EC
13D0:  MOVFF  24D,2EB
13D4:  MOVFF  24C,2EA
13D8:  RCALL  0D40
13DA:  MOVLB  2
13DC:  MOVF   x3F,W
13DE:  ADDWF  00,W
13E0:  MOVWF  x50
13E2:  MOVLW  00
13E4:  ADDWFC 01,W
13E6:  MOVWF  x51
13E8:  MOVLW  00
13EA:  ADDWFC 02,W
13EC:  MOVWF  x52
13EE:  MOVLW  00
13F0:  ADDWFC 03,W
13F2:  MOVWF  x53
....................    FileCurrentSector = 0; 
13F4:  CLRF   x55
13F6:  CLRF   x54
....................    FileLengthCount = 0; 
13F8:  CLRF   x59
13FA:  CLRF   x58
13FC:  CLRF   x57
13FE:  CLRF   x56
....................    FileSectorPosition = 0; 
1400:  CLRF   x5B
1402:  CLRF   x5A
....................  
....................    FileOpened = TRUE; 
1404:  BSF    x4B.2
.................... } 
1406:  MOVLB  0
1408:  GOTO   1E88 (RETURN)
....................  
.................... FILEDATA ReadFile(FILEDESCRIPTOR file, unsigned int32 count) 
.................... { 
....................    // Define the variables that will be used 
....................    FILEDATA data; 
....................    unsigned int16 bytesread = 0; 
140C:  MOVLB  2
140E:  CLRF   xE6
1410:  CLRF   xE7
....................    unsigned int16 i; 
....................  
....................    // Set initial values and initialize the Buffer vector 
....................    data.BytesRead = 0; 
1412:  CLRF   xE4
1414:  CLRF   xE3
....................    data.EOF = TRUE; 
1416:  BSF    xE5.0
....................  
....................    // Read the next file sector 
....................    ReadSector(FileCurrentLBA); 
1418:  MOVFF  253,301
141C:  MOVFF  252,300
1420:  MOVFF  251,2FF
1424:  MOVFF  250,2FE
1428:  MOVLB  0
142A:  CALL   0714
....................  
....................    // If the file has been opened with OpenFile() 
....................    if (FileOpened) 
142E:  MOVLB  2
1430:  BTFSS  x4B.2
1432:  BRA    15B6
....................    { 
....................        // Read 'count' bytes from the current file sector 
....................        for (i = 0; i < count; i++) 
1434:  CLRF   xE9
1436:  CLRF   xE8
1438:  MOVF   xC2,F
143A:  BNZ   144E
143C:  MOVF   xC1,F
143E:  BNZ   144E
1440:  MOVF   xE9,W
1442:  SUBWF  xC0,W
1444:  BNC   14BE
1446:  BNZ   144E
1448:  MOVF   xBF,W
144A:  SUBWF  xE8,W
144C:  BC    14BE
....................        { 
....................            // Increment the length count 
....................            FileLengthCount++; 
144E:  MOVLW  01
1450:  ADDWF  x56,F
1452:  BTFSC  FD8.0
1454:  INCF   x57,F
1456:  BTFSC  FD8.2
1458:  INCF   x58,F
145A:  BTFSC  FD8.2
145C:  INCF   x59,F
....................            // Compare the length count to the total file size 
....................            if (FileLengthCount <= file.Size) 
145E:  MOVF   x59,W
1460:  SUBWF  xBA,W
1462:  BNC   14B6
1464:  BNZ   147C
1466:  MOVF   x58,W
1468:  SUBWF  xB9,W
146A:  BNC   14B6
146C:  BNZ   147C
146E:  MOVF   x57,W
1470:  SUBWF  xB8,W
1472:  BNC   14B6
1474:  BNZ   147C
1476:  MOVF   x56,W
1478:  SUBWF  xB7,W
147A:  BNC   14B6
....................            { 
....................                // We only read if we have not reached the total file size 
....................                data.Buffer[i] = SectorBuffer[FileSectorPosition + i]; 
147C:  MOVLW  C3
147E:  ADDWF  xE8,W
1480:  MOVWF  01
1482:  MOVLW  02
1484:  ADDWFC xE9,W
1486:  MOVWF  03
1488:  MOVF   xE8,W
148A:  ADDWF  x5A,W
148C:  MOVWF  xEC
148E:  MOVF   xE9,W
1490:  ADDWFC x5B,W
1492:  MOVWF  xED
1494:  MOVLW  05
1496:  ADDWF  xEC,W
1498:  MOVWF  FE9
149A:  MOVLW  00
149C:  ADDWFC xED,W
149E:  MOVWF  FEA
14A0:  MOVFF  FEF,2EE
14A4:  MOVFF  03,FEA
14A8:  MOVFF  01,FE9
14AC:  MOVFF  2EE,FEF
....................                // Count the bytes that have been read 
....................                bytesread++; 
14B0:  INCF   xE6,F
14B2:  BTFSC  FD8.2
14B4:  INCF   xE7,F
....................            } 
....................        } 
14B6:  INCF   xE8,F
14B8:  BTFSC  FD8.2
14BA:  INCF   xE9,F
14BC:  BRA    1438
....................         
....................        // Set the bytes read into the resulting FileData structure 
....................        data.BytesRead = bytesread; 
14BE:  MOVFF  2E7,2E4
14C2:  MOVFF  2E6,2E3
....................  
....................        // Set the current sector position in order to continue from there the next time 
....................        FileSectorPosition += (unsigned int16)bytesread; 
14C6:  MOVF   xE6,W
14C8:  ADDWF  x5A,F
14CA:  MOVF   xE7,W
14CC:  ADDWFC x5B,F
....................  
....................        // If the sector position is greater than the maximum sector size 
....................        if (FileSectorPosition > (BUFFER_SIZE - 1)) 
14CE:  MOVF   x5B,W
14D0:  SUBLW  01
14D2:  BC    1568
....................        { 
....................            // Reset the file sector position 
....................            FileSectorPosition = 0; 
14D4:  CLRF   x5B
14D6:  CLRF   x5A
....................  
....................            // Increment the current sector 
....................            FileCurrentSector++; 
14D8:  INCF   x54,F
14DA:  BTFSC  FD8.2
14DC:  INCF   x55,F
....................            // If the current sector is minor than the Sectors Per Cluster 
....................            if (FileCurrentSector < SectorsPerCluster) 
14DE:  MOVF   x55,F
14E0:  BNZ   14FA
14E2:  MOVF   x27,W
14E4:  SUBWF  x54,W
14E6:  BC    14FA
....................            { 
....................                // Move to the next sector of the cluster 
....................                FileCurrentLBA++; 
14E8:  MOVLW  01
14EA:  ADDWF  x50,F
14EC:  BTFSC  FD8.0
14EE:  INCF   x51,F
14F0:  BTFSC  FD8.2
14F2:  INCF   x52,F
14F4:  BTFSC  FD8.2
14F6:  INCF   x53,F
....................            } 
....................            // If not, read the FAT looking for the next cluster 
....................            else 
14F8:  BRA    154E
....................            { 
....................                // And then, compute the first cluster sector 
....................                FileCurrentSector = 0; 
14FA:  CLRF   x55
14FC:  CLRF   x54
....................                FileCurrentCluster = ReadFAT(FileCurrentCluster); 
14FE:  MOVFF  24F,2ED
1502:  MOVFF  24E,2EC
1506:  MOVFF  24D,2EB
150A:  MOVFF  24C,2EA
150E:  MOVLB  0
1510:  RCALL  100A
1512:  MOVFF  03,24F
1516:  MOVFF  02,24E
151A:  MOVFF  01,24D
151E:  MOVFF  00,24C
....................                FileCurrentLBA = ComputeLBA(FileCurrentCluster) + FAT16offset; 
1522:  MOVFF  24F,2ED
1526:  MOVFF  24E,2EC
152A:  MOVFF  24D,2EB
152E:  MOVFF  24C,2EA
1532:  RCALL  0D40
1534:  MOVLB  2
1536:  MOVF   x3F,W
1538:  ADDWF  00,W
153A:  MOVWF  x50
153C:  MOVLW  00
153E:  ADDWFC 01,W
1540:  MOVWF  x51
1542:  MOVLW  00
1544:  ADDWFC 02,W
1546:  MOVWF  x52
1548:  MOVLW  00
154A:  ADDWFC 03,W
154C:  MOVWF  x53
....................            } 
....................            // Read the sector computer before 
....................            ReadSector(FileCurrentLBA); 
154E:  MOVFF  253,301
1552:  MOVFF  252,300
1556:  MOVFF  251,2FF
155A:  MOVFF  250,2FE
155E:  MOVLB  0
1560:  CALL   0714
....................        } 
....................        // If the sector position is greater than the sector buffer size 
....................        else 
1564:  BRA    1590
1566:  MOVLB  2
....................        { 
....................            // Check if the total file size has been reached 
....................            if (FileLengthCount >= file.Size) 
1568:  MOVF   xBA,W
156A:  SUBWF  x59,W
156C:  BNC   1590
156E:  BNZ   1586
1570:  MOVF   xB9,W
1572:  SUBWF  x58,W
1574:  BNC   1590
1576:  BNZ   1586
1578:  MOVF   xB8,W
157A:  SUBWF  x57,W
157C:  BNC   1590
157E:  BNZ   1586
1580:  MOVF   xB7,W
1582:  SUBWF  x56,W
1584:  BNC   1590
....................            { 
....................                // Force an EOF (End of File) 
....................                FileCurrentCluster = 0xFFFFFFFF; 
1586:  MOVLW  FF
1588:  MOVWF  x4F
158A:  MOVWF  x4E
158C:  MOVWF  x4D
158E:  MOVWF  x4C
....................            } 
....................        } 
....................  
....................        // If the current cluster is greater than 0xFFFFFFF8, we have an EOF 
....................        if (FileCurrentCluster < 0xFFFFFFF8) 
1590:  MOVLB  2
1592:  MOVF   x4F,W
1594:  SUBLW  FF
1596:  BNC   15B4
1598:  BNZ   15B0
159A:  MOVF   x4E,W
159C:  SUBLW  FF
159E:  BNC   15B4
15A0:  BNZ   15B0
15A2:  MOVF   x4D,W
15A4:  SUBLW  FF
15A6:  BNC   15B4
15A8:  BNZ   15B0
15AA:  MOVF   x4C,W
15AC:  SUBLW  F7
15AE:  BNC   15B4
....................        { 
....................            data.EOF = FALSE; 
15B0:  BCF    xE5.0
....................        } 
....................        else 
15B2:  BRA    15B6
....................        { 
....................            data.EOF = true; 
15B4:  BSF    xE5.0
....................        } 
....................    } 
....................  
....................    // Return the FileData structure 
....................    return data; 
15B6:  MOVLW  C3
15B8:  MOVWF  01
15BA:  MOVLW  02
15BC:  MOVWF  02
.................... } 
15BE:  MOVLB  0
15C0:  GOTO   1EFE (RETURN)
....................  
.................... void CloseFile() 
.................... { 
....................    // Close the currently opened file 
....................    FileOpened = FALSE; 
*
1610:  MOVLB  2
1612:  BCF    x4B.2
.................... } 
1614:  MOVLB  0
1616:  GOTO   1FA4 (RETURN)
....................  
....................  
.................... void main() 
.................... { 
*
1624:  CLRF   FF8
1626:  BCF    FD0.7
1628:  CLRF   FEA
162A:  CLRF   FE9
162C:  BCF    F93.7
162E:  BSF    F8A.7
1630:  BCF    FC6.5
1632:  BCF    F94.7
1634:  BSF    F93.0
1636:  BCF    F93.1
1638:  MOVLW  20
163A:  MOVWF  FC6
163C:  MOVLW  00
163E:  MOVWF  FC5
1640:  MOVF   FC1,W
1642:  ANDLW  C0
1644:  IORLW  0F
1646:  MOVWF  FC1
1648:  MOVLW  07
164A:  MOVWF  FB4
....................    unsigned int16 i; 
....................    unsigned int16 j; 
....................    unsigned int16 c; 
....................     
....................    // Create a file descriptor 
....................    FILEDESCRIPTOR fd; 
....................     
....................    // Create a FileData structure 
....................    FILEDATA data; 
....................        
....................    set_tris_a(0x00); 
164C:  MOVLW  00
164E:  MOVWF  F92
....................     
....................    if (SDInit() == TRUE) 
1650:  GOTO   0440
1654:  DECFSZ 01,W
1656:  BRA    167E
....................    { 
....................       printf("SD card initialized successfully!\r\n\r\n"); 
1658:  MOVLB  2
165A:  CLRF   xA0
165C:  MOVF   xA0,W
165E:  MOVLB  0
1660:  CALL   0004
1664:  MOVLB  2
1666:  INCF   xA0,F
1668:  MOVWF  00
166A:  MOVWF  xB1
166C:  MOVLB  0
166E:  CALL   05FA
1672:  MOVLW  25
1674:  MOVLB  2
1676:  SUBWF  xA0,W
1678:  BNZ   165C
....................    } else { 
167A:  BRA    16CC
167C:  MOVLB  0
....................       printf("Can not initialize SD card!\r\nHALTED!!!\r\n"); 
167E:  MOVLB  2
1680:  CLRF   xA0
1682:  MOVF   xA0,W
1684:  MOVLB  0
1686:  CALL   003A
168A:  MOVLB  2
168C:  INCF   xA0,F
168E:  MOVWF  00
1690:  MOVWF  xB1
1692:  MOVLB  0
1694:  CALL   05FA
1698:  MOVLW  23
169A:  MOVLB  2
169C:  SUBWF  xA0,W
169E:  BNZ   1682
16A0:  MOVLW  03
16A2:  MOVWF  xA1
16A4:  MOVLW  21
16A6:  MOVWF  xB1
16A8:  MOVLB  0
16AA:  CALL   05FA
16AE:  MOVLB  2
16B0:  DECFSZ xA1,F
16B2:  BRA    16A4
16B4:  MOVLW  0D
16B6:  MOVWF  xB1
16B8:  MOVLB  0
16BA:  CALL   05FA
16BE:  MOVLW  0A
16C0:  MOVLB  2
16C2:  MOVWF  xB1
16C4:  MOVLB  0
16C6:  CALL   05FA
....................       while (TRUE); 
16CA:  BRA    16CA
....................    } 
....................     
....................    // Find the first FAT partition 
....................    FindFirstFATPartition(); 
16CC:  MOVLB  0
16CE:  GOTO   0860
....................     
....................    printf("Partition LBA Begin: %lu\r\n", PartitionLBABegin); 
16D2:  MOVLB  2
16D4:  CLRF   xA0
16D6:  MOVF   xA0,W
16D8:  MOVLB  0
16DA:  CALL   0070
16DE:  MOVLB  2
16E0:  INCF   xA0,F
16E2:  MOVWF  00
16E4:  MOVWF  xB1
16E6:  MOVLB  0
16E8:  CALL   05FA
16EC:  MOVLW  15
16EE:  MOVLB  2
16F0:  SUBWF  xA0,W
16F2:  BNZ   16D6
16F4:  MOVLW  41
16F6:  MOVWF  FE9
16F8:  MOVFF  236,2A8
16FC:  MOVFF  235,2A7
1700:  MOVFF  234,2A6
1704:  MOVFF  233,2A5
1708:  MOVLB  0
170A:  CALL   0956
170E:  MOVLW  0D
1710:  MOVLB  2
1712:  MOVWF  xB1
1714:  MOVLB  0
1716:  CALL   05FA
171A:  MOVLW  0A
171C:  MOVLB  2
171E:  MOVWF  xB1
1720:  MOVLB  0
1722:  CALL   05FA
....................    if (pEntry.IsValid) 
1726:  MOVLB  2
1728:  BTFSS  x5C.0
172A:  BRA    1774
....................    { 
....................       if (pEntry.IsFAT32) 
172C:  BTFSS  x5C.1
172E:  BRA    1752
....................          printf("System is: FAT32\r\n"); 
1730:  CLRF   xA0
1732:  MOVF   xA0,W
1734:  MOVLB  0
1736:  CALL   009C
173A:  MOVLB  2
173C:  INCF   xA0,F
173E:  MOVWF  00
1740:  MOVWF  xB1
1742:  MOVLB  0
1744:  CALL   05FA
1748:  MOVLW  12
174A:  MOVLB  2
174C:  SUBWF  xA0,W
174E:  BNZ   1732
....................       else 
1750:  BRA    1772
....................          printf("System is: FAT16\r\n"); 
1752:  CLRF   xA0
1754:  MOVF   xA0,W
1756:  MOVLB  0
1758:  CALL   00C0
175C:  MOVLB  2
175E:  INCF   xA0,F
1760:  MOVWF  00
1762:  MOVWF  xB1
1764:  MOVLB  0
1766:  CALL   05FA
176A:  MOVLW  12
176C:  MOVLB  2
176E:  SUBWF  xA0,W
1770:  BNZ   1754
....................    } else { 
1772:  BRA    1794
....................       printf("Memory format not FAT16 or FAT32\r\n"); 
1774:  CLRF   xA0
1776:  MOVF   xA0,W
1778:  MOVLB  0
177A:  CALL   00E4
177E:  MOVLB  2
1780:  INCF   xA0,F
1782:  MOVWF  00
1784:  MOVWF  xB1
1786:  MOVLB  0
1788:  CALL   05FA
178C:  MOVLW  22
178E:  MOVLB  2
1790:  SUBWF  xA0,W
1792:  BNZ   1776
....................    } 
....................     
....................    // Read the Volume ID to get some information important for further calculations 
....................    // If the function ReadVolumeID() returns True, it is a FAT32 volume. 
....................    if (ReadVolumeID() == TRUE) 
1794:  MOVLB  0
1796:  GOTO   0A74
179A:  DECFSZ 01,W
179C:  GOTO   1FF0
....................    { 
....................        printf("Bytes per sector: %lu\r\n", BytesPerSector); 
17A0:  MOVLB  2
17A2:  CLRF   xA0
17A4:  MOVF   xA0,W
17A6:  MOVLB  0
17A8:  CALL   0118
17AC:  MOVLB  2
17AE:  INCF   xA0,F
17B0:  MOVWF  00
17B2:  MOVWF  xB1
17B4:  MOVLB  0
17B6:  CALL   05FA
17BA:  MOVLW  12
17BC:  MOVLB  2
17BE:  SUBWF  xA0,W
17C0:  BNZ   17A4
17C2:  MOVLW  10
17C4:  MOVWF  FE9
17C6:  MOVFF  226,2A2
17CA:  MOVFF  225,2A1
17CE:  MOVLB  0
17D0:  CALL   0BDC
17D4:  MOVLW  0D
17D6:  MOVLB  2
17D8:  MOVWF  xB1
17DA:  MOVLB  0
17DC:  CALL   05FA
17E0:  MOVLW  0A
17E2:  MOVLB  2
17E4:  MOVWF  xB1
17E6:  MOVLB  0
17E8:  CALL   05FA
....................        printf("Sectors per cluster: %u\r\n", SectorsPerCluster); 
17EC:  MOVLB  2
17EE:  CLRF   xA0
17F0:  MOVF   xA0,W
17F2:  MOVLB  0
17F4:  CALL   0140
17F8:  MOVLB  2
17FA:  INCF   xA0,F
17FC:  MOVWF  00
17FE:  MOVWF  xB1
1800:  MOVLB  0
1802:  CALL   05FA
1806:  MOVLW  15
1808:  MOVLB  2
180A:  SUBWF  xA0,W
180C:  BNZ   17F0
180E:  MOVFF  227,2A1
1812:  MOVLW  1B
1814:  MOVWF  xA2
1816:  MOVLB  0
1818:  CALL   0CC4
181C:  MOVLW  0D
181E:  MOVLB  2
1820:  MOVWF  xB1
1822:  MOVLB  0
1824:  CALL   05FA
1828:  MOVLW  0A
182A:  MOVLB  2
182C:  MOVWF  xB1
182E:  MOVLB  0
1830:  CALL   05FA
....................        printf("Number of reserved sectors: %lu\r\n", NumberOfReservedSectors); 
1834:  MOVLB  2
1836:  CLRF   xA0
1838:  MOVF   xA0,W
183A:  MOVLB  0
183C:  CALL   016A
1840:  MOVLB  2
1842:  INCF   xA0,F
1844:  MOVWF  00
1846:  MOVWF  xB1
1848:  MOVLB  0
184A:  CALL   05FA
184E:  MOVLW  1C
1850:  MOVLB  2
1852:  SUBWF  xA0,W
1854:  BNZ   1838
1856:  MOVLW  10
1858:  MOVWF  FE9
185A:  MOVFF  229,2A2
185E:  MOVFF  228,2A1
1862:  MOVLB  0
1864:  CALL   0BDC
1868:  MOVLW  0D
186A:  MOVLB  2
186C:  MOVWF  xB1
186E:  MOVLB  0
1870:  CALL   05FA
1874:  MOVLW  0A
1876:  MOVLB  2
1878:  MOVWF  xB1
187A:  MOVLB  0
187C:  CALL   05FA
....................        printf("Number of FATs: %u\r\n", NumberOfFATs); 
1880:  MOVLB  2
1882:  CLRF   xA0
1884:  MOVF   xA0,W
1886:  MOVLB  0
1888:  CALL   019C
188C:  MOVLB  2
188E:  INCF   xA0,F
1890:  MOVWF  00
1892:  MOVWF  xB1
1894:  MOVLB  0
1896:  CALL   05FA
189A:  MOVLW  10
189C:  MOVLB  2
189E:  SUBWF  xA0,W
18A0:  BNZ   1884
18A2:  MOVFF  22A,2A1
18A6:  MOVLW  1B
18A8:  MOVWF  xA2
18AA:  MOVLB  0
18AC:  CALL   0CC4
18B0:  MOVLW  0D
18B2:  MOVLB  2
18B4:  MOVWF  xB1
18B6:  MOVLB  0
18B8:  CALL   05FA
18BC:  MOVLW  0A
18BE:  MOVLB  2
18C0:  MOVWF  xB1
18C2:  MOVLB  0
18C4:  CALL   05FA
....................        printf("Sectors per FAT: %lu\r\n", SectorsPerFAT); 
18C8:  MOVLB  2
18CA:  CLRF   xA0
18CC:  MOVF   xA0,W
18CE:  MOVLB  0
18D0:  CALL   01C2
18D4:  MOVLB  2
18D6:  INCF   xA0,F
18D8:  MOVWF  00
18DA:  MOVWF  xB1
18DC:  MOVLB  0
18DE:  CALL   05FA
18E2:  MOVLW  11
18E4:  MOVLB  2
18E6:  SUBWF  xA0,W
18E8:  BNZ   18CC
18EA:  MOVLW  41
18EC:  MOVWF  FE9
18EE:  MOVFF  22E,2A8
18F2:  MOVFF  22D,2A7
18F6:  MOVFF  22C,2A6
18FA:  MOVFF  22B,2A5
18FE:  MOVLB  0
1900:  CALL   0956
1904:  MOVLW  0D
1906:  MOVLB  2
1908:  MOVWF  xB1
190A:  MOVLB  0
190C:  CALL   05FA
1910:  MOVLW  0A
1912:  MOVLB  2
1914:  MOVWF  xB1
1916:  MOVLB  0
1918:  CALL   05FA
....................        printf("Root directory first cluster: %lu\r\n", RootDirectoryFirstCluster); 
191C:  MOVLB  2
191E:  CLRF   xA0
1920:  MOVF   xA0,W
1922:  MOVLB  0
1924:  CALL   01EA
1928:  MOVLB  2
192A:  INCF   xA0,F
192C:  MOVWF  00
192E:  MOVWF  xB1
1930:  MOVLB  0
1932:  CALL   05FA
1936:  MOVLW  1E
1938:  MOVLB  2
193A:  SUBWF  xA0,W
193C:  BNZ   1920
193E:  MOVLW  41
1940:  MOVWF  FE9
1942:  MOVFF  232,2A8
1946:  MOVFF  231,2A7
194A:  MOVFF  230,2A6
194E:  MOVFF  22F,2A5
1952:  MOVLB  0
1954:  CALL   0956
1958:  MOVLW  0D
195A:  MOVLB  2
195C:  MOVWF  xB1
195E:  MOVLB  0
1960:  CALL   05FA
1964:  MOVLW  0A
1966:  MOVLB  2
1968:  MOVWF  xB1
196A:  MOVLB  0
196C:  CALL   05FA
....................        printf("FAT begin LBA: %lu\r\n", FatBeginLBA); 
1970:  MOVLB  2
1972:  CLRF   xA0
1974:  MOVF   xA0,W
1976:  MOVLB  0
1978:  CALL   021E
197C:  MOVLB  2
197E:  INCF   xA0,F
1980:  MOVWF  00
1982:  MOVWF  xB1
1984:  MOVLB  0
1986:  CALL   05FA
198A:  MOVLW  0F
198C:  MOVLB  2
198E:  SUBWF  xA0,W
1990:  BNZ   1974
1992:  MOVLW  41
1994:  MOVWF  FE9
1996:  MOVFF  23A,2A8
199A:  MOVFF  239,2A7
199E:  MOVFF  238,2A6
19A2:  MOVFF  237,2A5
19A6:  MOVLB  0
19A8:  CALL   0956
19AC:  MOVLW  0D
19AE:  MOVLB  2
19B0:  MOVWF  xB1
19B2:  MOVLB  0
19B4:  CALL   05FA
19B8:  MOVLW  0A
19BA:  MOVLB  2
19BC:  MOVWF  xB1
19BE:  MOVLB  0
19C0:  CALL   05FA
....................        printf("Data begin LBA: %lu\r\n", DataBeginLBA+FAT16offset); 
19C4:  MOVLB  2
19C6:  MOVF   x3F,W
19C8:  ADDWF  x3B,W
19CA:  MOVWF  xA0
19CC:  MOVLW  00
19CE:  ADDWFC x3C,W
19D0:  MOVWF  xA1
19D2:  MOVLW  00
19D4:  ADDWFC x3D,W
19D6:  MOVWF  xA2
19D8:  MOVLW  00
19DA:  ADDWFC x3E,W
19DC:  MOVWF  xA3
19DE:  CLRF   xA4
19E0:  MOVF   xA4,W
19E2:  MOVLB  0
19E4:  CALL   0244
19E8:  MOVLB  2
19EA:  INCF   xA4,F
19EC:  MOVWF  00
19EE:  MOVWF  xB1
19F0:  MOVLB  0
19F2:  CALL   05FA
19F6:  MOVLW  10
19F8:  MOVLB  2
19FA:  SUBWF  xA4,W
19FC:  BNZ   19E0
19FE:  MOVLW  41
1A00:  MOVWF  FE9
1A02:  MOVFF  2A3,2A8
1A06:  MOVFF  2A2,2A7
1A0A:  MOVFF  2A1,2A6
1A0E:  MOVFF  2A0,2A5
1A12:  MOVLB  0
1A14:  CALL   0956
1A18:  MOVLW  0D
1A1A:  MOVLB  2
1A1C:  MOVWF  xB1
1A1E:  MOVLB  0
1A20:  CALL   05FA
1A24:  MOVLW  0A
1A26:  MOVLB  2
1A28:  MOVWF  xB1
1A2A:  MOVLB  0
1A2C:  CALL   05FA
....................        printf("Root Directory LBA: %lu\r\n", ComputeLBA(RootDirectoryFirstCluster)); 
1A30:  MOVFF  232,2ED
1A34:  MOVFF  231,2EC
1A38:  MOVFF  230,2EB
1A3C:  MOVFF  22F,2EA
1A40:  CALL   0D40
1A44:  MOVFF  03,2A3
1A48:  MOVFF  02,2A2
1A4C:  MOVFF  01,2A1
1A50:  MOVFF  00,2A0
1A54:  MOVLB  2
1A56:  CLRF   xA4
1A58:  MOVF   xA4,W
1A5A:  MOVLB  0
1A5C:  CALL   026A
1A60:  MOVLB  2
1A62:  INCF   xA4,F
1A64:  MOVWF  00
1A66:  MOVWF  xB1
1A68:  MOVLB  0
1A6A:  CALL   05FA
1A6E:  MOVLW  14
1A70:  MOVLB  2
1A72:  SUBWF  xA4,W
1A74:  BNZ   1A58
1A76:  MOVLW  41
1A78:  MOVWF  FE9
1A7A:  MOVFF  2A3,2A8
1A7E:  MOVFF  2A2,2A7
1A82:  MOVFF  2A1,2A6
1A86:  MOVFF  2A0,2A5
1A8A:  MOVLB  0
1A8C:  CALL   0956
1A90:  MOVLW  0D
1A92:  MOVLB  2
1A94:  MOVWF  xB1
1A96:  MOVLB  0
1A98:  CALL   05FA
1A9C:  MOVLW  0A
1A9E:  MOVLB  2
1AA0:  MOVWF  xB1
1AA2:  MOVLB  0
1AA4:  CALL   05FA
....................     
....................        printf("\r\n"); 
1AA8:  MOVLW  0D
1AAA:  MOVLB  2
1AAC:  MOVWF  xB1
1AAE:  MOVLB  0
1AB0:  CALL   05FA
1AB4:  MOVLW  0A
1AB6:  MOVLB  2
1AB8:  MOVWF  xB1
1ABA:  MOVLB  0
1ABC:  CALL   05FA
....................     
....................        // Open the root directory passing the Root Directory First Cluster 
....................        // to the function OpenDirectory. You can open another directory 
....................        // just passing its first cluster. 
....................        OpenDirectory(RootDirectoryFirstCluster); 
1AC0:  MOVFF  232,2A3
1AC4:  MOVFF  231,2A2
1AC8:  MOVFF  230,2A1
1ACC:  MOVFF  22F,2A0
1AD0:  GOTO   0DAE
....................  
....................        // We move on through the directory looking for files. If we get some file with size 
....................        // greater than zero, we can read it. 
....................        //fd = FindNextFile(); 
....................        do 
....................        { 
....................            // Repeat the process until no more files are found 
....................            fd = FindNextFile(); 
1AD4:  GOTO   11F2
1AD8:  MOVFF  02,2A1
1ADC:  MOVLB  2
1ADE:  MOVFF  01,2A0
1AE2:  MOVLW  02
1AE4:  MOVWF  FEA
1AE6:  MOVLW  64
1AE8:  MOVWF  FE9
1AEA:  MOVFF  02,FE2
1AEE:  MOVFF  01,FE1
1AF2:  MOVLW  19
1AF4:  MOVWF  01
1AF6:  MOVFF  FE6,FEE
1AFA:  DECFSZ 01,F
1AFC:  BRA    1AF6
....................            if(bit_test(fd.Attributes,4)) 
1AFE:  BTFSS  x70.4
1B00:  BRA    1C2E
....................            { 
....................               printf("Dir:"); 
1B02:  CLRF   xA0
1B04:  MOVF   xA0,W
1B06:  MOVLB  0
1B08:  CALL   0294
1B0C:  MOVLB  2
1B0E:  INCF   xA0,F
1B10:  MOVWF  00
1B12:  MOVWF  xB1
1B14:  MOVLB  0
1B16:  CALL   05FA
1B1A:  MOVLW  04
1B1C:  MOVLB  2
1B1E:  SUBWF  xA0,W
1B20:  BNZ   1B04
....................               for (i = 0; i < FILENAME_SIZE; i++) 
1B22:  CLRF   x5F
1B24:  CLRF   x5E
1B26:  MOVF   x5F,F
1B28:  BNZ   1B54
1B2A:  MOVF   x5E,W
1B2C:  SUBLW  0B
1B2E:  BNC   1B54
....................               { 
....................                   printf("%c", fd.Name[i]); 
1B30:  MOVLW  64
1B32:  ADDWF  x5E,W
1B34:  MOVWF  FE9
1B36:  MOVLW  02
1B38:  ADDWFC x5F,W
1B3A:  MOVWF  FEA
1B3C:  MOVFF  FEF,2A0
1B40:  MOVFF  2A0,2B1
1B44:  MOVLB  0
1B46:  CALL   05FA
....................               } 
1B4A:  MOVLB  2
1B4C:  INCF   x5E,F
1B4E:  BTFSC  FD8.2
1B50:  INCF   x5F,F
1B52:  BRA    1B26
....................               printf("\r\n"); 
1B54:  MOVLW  0D
1B56:  MOVWF  xB1
1B58:  MOVLB  0
1B5A:  CALL   05FA
1B5E:  MOVLW  0A
1B60:  MOVLB  2
1B62:  MOVWF  xB1
1B64:  MOVLB  0
1B66:  CALL   05FA
....................               printf("First LBA: %lu\r\n", fd.FirstLBA); 
1B6A:  MOVLB  2
1B6C:  CLRF   xA0
1B6E:  MOVF   xA0,W
1B70:  MOVLB  0
1B72:  CALL   02AA
1B76:  MOVLB  2
1B78:  INCF   xA0,F
1B7A:  MOVWF  00
1B7C:  MOVWF  xB1
1B7E:  MOVLB  0
1B80:  CALL   05FA
1B84:  MOVLW  0B
1B86:  MOVLB  2
1B88:  SUBWF  xA0,W
1B8A:  BNZ   1B6E
1B8C:  MOVLW  41
1B8E:  MOVWF  FE9
1B90:  MOVFF  274,2A8
1B94:  MOVFF  273,2A7
1B98:  MOVFF  272,2A6
1B9C:  MOVFF  271,2A5
1BA0:  MOVLB  0
1BA2:  CALL   0956
1BA6:  MOVLW  0D
1BA8:  MOVLB  2
1BAA:  MOVWF  xB1
1BAC:  MOVLB  0
1BAE:  CALL   05FA
1BB2:  MOVLW  0A
1BB4:  MOVLB  2
1BB6:  MOVWF  xB1
1BB8:  MOVLB  0
1BBA:  CALL   05FA
....................               printf("First Cluster: %lu\r\n", fd.FirstCluster); 
1BBE:  MOVLB  2
1BC0:  CLRF   xA0
1BC2:  MOVF   xA0,W
1BC4:  MOVLB  0
1BC6:  CALL   02CC
1BCA:  MOVLB  2
1BCC:  INCF   xA0,F
1BCE:  MOVWF  00
1BD0:  MOVWF  xB1
1BD2:  MOVLB  0
1BD4:  CALL   05FA
1BD8:  MOVLW  0F
1BDA:  MOVLB  2
1BDC:  SUBWF  xA0,W
1BDE:  BNZ   1BC2
1BE0:  MOVLW  41
1BE2:  MOVWF  FE9
1BE4:  MOVFF  27C,2A8
1BE8:  MOVFF  27B,2A7
1BEC:  MOVFF  27A,2A6
1BF0:  MOVFF  279,2A5
1BF4:  MOVLB  0
1BF6:  CALL   0956
1BFA:  MOVLW  0D
1BFC:  MOVLB  2
1BFE:  MOVWF  xB1
1C00:  MOVLB  0
1C02:  CALL   05FA
1C06:  MOVLW  0A
1C08:  MOVLB  2
1C0A:  MOVWF  xB1
1C0C:  MOVLB  0
1C0E:  CALL   05FA
....................               printf("\r\n"); 
1C12:  MOVLW  0D
1C14:  MOVLB  2
1C16:  MOVWF  xB1
1C18:  MOVLB  0
1C1A:  CALL   05FA
1C1E:  MOVLW  0A
1C20:  MOVLB  2
1C22:  MOVWF  xB1
1C24:  MOVLB  0
1C26:  CALL   05FA
....................            }else{ 
1C2A:  BRA    1FBC
1C2C:  MOVLB  2
....................              if(fd.Size > 0) 
1C2E:  MOVF   x75,F
1C30:  BNZ   1C40
1C32:  MOVF   x76,F
1C34:  BNZ   1C40
1C36:  MOVF   x77,F
1C38:  BNZ   1C40
1C3A:  MOVF   x78,F
1C3C:  BTFSC  FD8.2
1C3E:  BRA    1FBE
....................              { 
....................                  // A file has been found and we display its name, size, first LBA sector, etc. 
....................                  printf("File:"); 
1C40:  CLRF   xA0
1C42:  MOVF   xA0,W
1C44:  MOVLB  0
1C46:  CALL   02F2
1C4A:  MOVLB  2
1C4C:  INCF   xA0,F
1C4E:  MOVWF  00
1C50:  MOVWF  xB1
1C52:  MOVLB  0
1C54:  CALL   05FA
1C58:  MOVLW  05
1C5A:  MOVLB  2
1C5C:  SUBWF  xA0,W
1C5E:  BNZ   1C42
....................                  for (i = 0; i < FILENAME_SIZE; i++) 
1C60:  CLRF   x5F
1C62:  CLRF   x5E
1C64:  MOVF   x5F,F
1C66:  BNZ   1C92
1C68:  MOVF   x5E,W
1C6A:  SUBLW  0B
1C6C:  BNC   1C92
....................                  { 
....................                      printf("%c", fd.Name[i]); 
1C6E:  MOVLW  64
1C70:  ADDWF  x5E,W
1C72:  MOVWF  FE9
1C74:  MOVLW  02
1C76:  ADDWFC x5F,W
1C78:  MOVWF  FEA
1C7A:  MOVFF  FEF,2A0
1C7E:  MOVFF  2A0,2B1
1C82:  MOVLB  0
1C84:  CALL   05FA
....................                  } 
1C88:  MOVLB  2
1C8A:  INCF   x5E,F
1C8C:  BTFSC  FD8.2
1C8E:  INCF   x5F,F
1C90:  BRA    1C64
....................                  printf("\r\n"); 
1C92:  MOVLW  0D
1C94:  MOVWF  xB1
1C96:  MOVLB  0
1C98:  CALL   05FA
1C9C:  MOVLW  0A
1C9E:  MOVLB  2
1CA0:  MOVWF  xB1
1CA2:  MOVLB  0
1CA4:  CALL   05FA
....................                  printf("Size: %lu bytes\r\n", fd.Size); 
1CA8:  MOVLB  2
1CAA:  CLRF   xA0
1CAC:  MOVF   xA0,W
1CAE:  MOVLB  0
1CB0:  CALL   0308
1CB4:  MOVLB  2
1CB6:  INCF   xA0,F
1CB8:  MOVWF  00
1CBA:  MOVWF  xB1
1CBC:  MOVLB  0
1CBE:  CALL   05FA
1CC2:  MOVLW  06
1CC4:  MOVLB  2
1CC6:  SUBWF  xA0,W
1CC8:  BNZ   1CAC
1CCA:  MOVLW  41
1CCC:  MOVWF  FE9
1CCE:  MOVFF  278,2A8
1CD2:  MOVFF  277,2A7
1CD6:  MOVFF  276,2A6
1CDA:  MOVFF  275,2A5
1CDE:  MOVLB  0
1CE0:  CALL   0956
1CE4:  MOVLW  09
1CE6:  MOVLB  2
1CE8:  MOVWF  xA1
1CEA:  MOVF   xA1,W
1CEC:  MOVLB  0
1CEE:  CALL   0308
1CF2:  MOVLB  2
1CF4:  INCF   xA1,F
1CF6:  MOVWF  00
1CF8:  MOVWF  xB1
1CFA:  MOVLB  0
1CFC:  CALL   05FA
1D00:  MOVLW  11
1D02:  MOVLB  2
1D04:  SUBWF  xA1,W
1D06:  BNZ   1CEA
....................                  printf("First LBA: %lu\r\n", fd.FirstLBA); 
1D08:  CLRF   xA0
1D0A:  MOVF   xA0,W
1D0C:  MOVLB  0
1D0E:  CALL   02AA
1D12:  MOVLB  2
1D14:  INCF   xA0,F
1D16:  MOVWF  00
1D18:  MOVWF  xB1
1D1A:  MOVLB  0
1D1C:  CALL   05FA
1D20:  MOVLW  0B
1D22:  MOVLB  2
1D24:  SUBWF  xA0,W
1D26:  BNZ   1D0A
1D28:  MOVLW  41
1D2A:  MOVWF  FE9
1D2C:  MOVFF  274,2A8
1D30:  MOVFF  273,2A7
1D34:  MOVFF  272,2A6
1D38:  MOVFF  271,2A5
1D3C:  MOVLB  0
1D3E:  CALL   0956
1D42:  MOVLW  0D
1D44:  MOVLB  2
1D46:  MOVWF  xB1
1D48:  MOVLB  0
1D4A:  CALL   05FA
1D4E:  MOVLW  0A
1D50:  MOVLB  2
1D52:  MOVWF  xB1
1D54:  MOVLB  0
1D56:  CALL   05FA
....................                  printf("First Cluster: %lu\r\n", fd.FirstCluster); 
1D5A:  MOVLB  2
1D5C:  CLRF   xA0
1D5E:  MOVF   xA0,W
1D60:  MOVLB  0
1D62:  CALL   02CC
1D66:  MOVLB  2
1D68:  INCF   xA0,F
1D6A:  MOVWF  00
1D6C:  MOVWF  xB1
1D6E:  MOVLB  0
1D70:  CALL   05FA
1D74:  MOVLW  0F
1D76:  MOVLB  2
1D78:  SUBWF  xA0,W
1D7A:  BNZ   1D5E
1D7C:  MOVLW  41
1D7E:  MOVWF  FE9
1D80:  MOVFF  27C,2A8
1D84:  MOVFF  27B,2A7
1D88:  MOVFF  27A,2A6
1D8C:  MOVFF  279,2A5
1D90:  MOVLB  0
1D92:  CALL   0956
1D96:  MOVLW  0D
1D98:  MOVLB  2
1D9A:  MOVWF  xB1
1D9C:  MOVLB  0
1D9E:  CALL   05FA
1DA2:  MOVLW  0A
1DA4:  MOVLB  2
1DA6:  MOVWF  xB1
1DA8:  MOVLB  0
1DAA:  CALL   05FA
....................                  printf("\r\n"); 
1DAE:  MOVLW  0D
1DB0:  MOVLB  2
1DB2:  MOVWF  xB1
1DB4:  MOVLB  0
1DB6:  CALL   05FA
1DBA:  MOVLW  0A
1DBC:  MOVLB  2
1DBE:  MOVWF  xB1
1DC0:  MOVLB  0
1DC2:  CALL   05FA
....................                   
....................                  printf("Showing file's first 32 bytes...\r\n\r\n"); 
1DC6:  MOVLB  2
1DC8:  CLRF   xA0
1DCA:  MOVF   xA0,W
1DCC:  MOVLB  0
1DCE:  CALL   032A
1DD2:  MOVLB  2
1DD4:  INCF   xA0,F
1DD6:  MOVWF  00
1DD8:  MOVWF  xB1
1DDA:  MOVLB  0
1DDC:  CALL   05FA
1DE0:  MOVLW  1D
1DE2:  MOVLB  2
1DE4:  SUBWF  xA0,W
1DE6:  BNZ   1DCA
1DE8:  MOVLW  03
1DEA:  MOVWF  xA1
1DEC:  MOVLW  2E
1DEE:  MOVWF  xB1
1DF0:  MOVLB  0
1DF2:  CALL   05FA
1DF6:  MOVLB  2
1DF8:  DECFSZ xA1,F
1DFA:  BRA    1DEC
1DFC:  MOVLW  1D
1DFE:  MOVWF  xA2
1E00:  MOVF   xA2,W
1E02:  MOVLB  0
1E04:  CALL   032A
1E08:  MOVLB  2
1E0A:  INCF   xA2,F
1E0C:  MOVWF  00
1E0E:  MOVWF  xB1
1E10:  MOVLB  0
1E12:  CALL   05FA
1E16:  MOVLW  21
1E18:  MOVLB  2
1E1A:  SUBWF  xA2,W
1E1C:  BNZ   1E00
....................                   
....................                  // Open the file obtained with FindNextFile 
....................                  OpenFile(fd); 
1E1E:  MOVFF  264,2A0
1E22:  MOVFF  265,2A1
1E26:  MOVFF  266,2A2
1E2A:  MOVFF  267,2A3
1E2E:  MOVFF  268,2A4
1E32:  MOVFF  269,2A5
1E36:  MOVFF  26A,2A6
1E3A:  MOVFF  26B,2A7
1E3E:  MOVFF  26C,2A8
1E42:  MOVFF  26D,2A9
1E46:  MOVFF  26E,2AA
1E4A:  MOVFF  26F,2AB
1E4E:  MOVFF  270,2AC
1E52:  MOVFF  271,2AD
1E56:  MOVFF  272,2AE
1E5A:  MOVFF  273,2AF
1E5E:  MOVFF  274,2B0
1E62:  MOVFF  275,2B1
1E66:  MOVFF  276,2B2
1E6A:  MOVFF  277,2B3
1E6E:  MOVFF  278,2B4
1E72:  MOVFF  279,2B5
1E76:  MOVFF  27A,2B6
1E7A:  MOVFF  27B,2B7
1E7E:  MOVFF  27C,2B8
1E82:  MOVLB  0
1E84:  GOTO   13B8
....................        
....................                  // Get some data in 32 bytes chunks. It is very important to use 
....................                  // the FILEDATA_SIZE constant. You can change this constant to use 
....................                  // another size that must be multiple of 2, like 1, 32, 64, 256, or 512. 
....................                  // The maximum buffer size allowed is 512. 
....................                  data = ReadFile(fd, FILEDATA_SIZE); 
1E88:  MOVFF  264,2A6
1E8C:  MOVFF  265,2A7
1E90:  MOVFF  266,2A8
1E94:  MOVFF  267,2A9
1E98:  MOVFF  268,2AA
1E9C:  MOVFF  269,2AB
1EA0:  MOVFF  26A,2AC
1EA4:  MOVFF  26B,2AD
1EA8:  MOVFF  26C,2AE
1EAC:  MOVFF  26D,2AF
1EB0:  MOVFF  26E,2B0
1EB4:  MOVFF  26F,2B1
1EB8:  MOVFF  270,2B2
1EBC:  MOVFF  271,2B3
1EC0:  MOVFF  272,2B4
1EC4:  MOVFF  273,2B5
1EC8:  MOVFF  274,2B6
1ECC:  MOVFF  275,2B7
1ED0:  MOVFF  276,2B8
1ED4:  MOVFF  277,2B9
1ED8:  MOVFF  278,2BA
1EDC:  MOVFF  279,2BB
1EE0:  MOVFF  27A,2BC
1EE4:  MOVFF  27B,2BD
1EE8:  MOVFF  27C,2BE
1EEC:  MOVLB  2
1EEE:  CLRF   xC2
1EF0:  CLRF   xC1
1EF2:  CLRF   xC0
1EF4:  MOVLW  20
1EF6:  MOVWF  xBF
1EF8:  MOVLB  0
1EFA:  GOTO   140C
1EFE:  MOVFF  02,2A1
1F02:  MOVLB  2
1F04:  MOVFF  01,2A0
1F08:  MOVLW  02
1F0A:  MOVWF  FEA
1F0C:  MOVLW  7D
1F0E:  MOVWF  FE9
1F10:  MOVFF  02,FE2
1F14:  MOVFF  01,FE1
1F18:  MOVLW  23
1F1A:  MOVWF  01
1F1C:  MOVFF  FE6,FEE
1F20:  DECFSZ 01,F
1F22:  BRA    1F1C
....................                    
....................                  // Show file's first 32 bytes 
....................                  c = 0; 
1F24:  CLRF   x63
1F26:  CLRF   x62
....................                  for (i = 0; i < 2; i++) 
1F28:  CLRF   x5F
1F2A:  CLRF   x5E
1F2C:  MOVF   x5F,F
1F2E:  BNZ   1F9E
1F30:  MOVF   x5E,W
1F32:  SUBLW  01
1F34:  BNC   1F9E
....................                  { 
....................                      for (j = 0; j < 16; j++) 
1F36:  CLRF   x61
1F38:  CLRF   x60
1F3A:  MOVF   x61,F
1F3C:  BNZ   1F7E
1F3E:  MOVF   x60,W
1F40:  SUBLW  0F
1F42:  BNC   1F7E
....................                      { 
....................                         printf("%2X ", data.Buffer[c]); 
1F44:  MOVLW  7D
1F46:  ADDWF  x62,W
1F48:  MOVWF  FE9
1F4A:  MOVLW  02
1F4C:  ADDWFC x63,W
1F4E:  MOVWF  FEA
1F50:  MOVFF  FEF,2A0
1F54:  MOVFF  2A0,2A1
1F58:  MOVLW  37
1F5A:  MOVWF  xA2
1F5C:  MOVLB  0
1F5E:  GOTO   15C4
1F62:  MOVLW  20
1F64:  MOVLB  2
1F66:  MOVWF  xB1
1F68:  MOVLB  0
1F6A:  CALL   05FA
....................                         c++; 
1F6E:  MOVLB  2
1F70:  INCF   x62,F
1F72:  BTFSC  FD8.2
1F74:  INCF   x63,F
....................                      } 
1F76:  INCF   x60,F
1F78:  BTFSC  FD8.2
1F7A:  INCF   x61,F
1F7C:  BRA    1F3A
....................                      printf("\r\n"); 
1F7E:  MOVLW  0D
1F80:  MOVWF  xB1
1F82:  MOVLB  0
1F84:  CALL   05FA
1F88:  MOVLW  0A
1F8A:  MOVLB  2
1F8C:  MOVWF  xB1
1F8E:  MOVLB  0
1F90:  CALL   05FA
....................                  } 
1F94:  MOVLB  2
1F96:  INCF   x5E,F
1F98:  BTFSC  FD8.2
1F9A:  INCF   x5F,F
1F9C:  BRA    1F2C
....................                   
....................                  // Close the opened file handlers 
....................                  CloseFile(); 
1F9E:  MOVLB  0
1FA0:  GOTO   1610
....................                   
....................                  printf("\r\n"); 
1FA4:  MOVLW  0D
1FA6:  MOVLB  2
1FA8:  MOVWF  xB1
1FAA:  MOVLB  0
1FAC:  CALL   05FA
1FB0:  MOVLW  0A
1FB2:  MOVLB  2
1FB4:  MOVWF  xB1
1FB6:  MOVLB  0
1FB8:  CALL   05FA
1FBC:  MOVLB  2
....................              } 
....................           } 
....................        }while(!EODReached); 
1FBE:  BTFSC  x4B.1
1FC0:  BRA    1FC6
1FC2:  MOVLB  0
1FC4:  BRA    1AD4
....................     
....................        // Close the directory handlers 
....................        CloseDirectory(); 
1FC6:  MOVLB  0
1FC8:  GOTO   161A
....................     
....................        // Display a final message 
....................        printf("No more files in root directory!\r\n"); 
1FCC:  MOVLB  2
1FCE:  CLRF   xA0
1FD0:  MOVF   xA0,W
1FD2:  MOVLB  0
1FD4:  CALL   035C
1FD8:  MOVLB  2
1FDA:  INCF   xA0,F
1FDC:  MOVWF  00
1FDE:  MOVWF  xB1
1FE0:  MOVLB  0
1FE2:  CALL   05FA
1FE6:  MOVLW  22
1FE8:  MOVLB  2
1FEA:  SUBWF  xA0,W
1FEC:  BNZ   1FD0
1FEE:  MOVLB  0
....................    } 
....................     
....................    while (TRUE); 
1FF0:  BRA    1FF0
.................... } 
....................  
1FF2:  SLEEP 

Configuration Fuses:
   Word  1: 0C20   NOIESO NOFCMEN HS PLL1 CPUDIV1 USBDIV
   Word  2: 1E19   NOBROWNOUT NOWDT BORV20 NOPUT WDT32768 NOVREGEN RESERVED
   Word  3: 8300   PBADEN CCP2C1 MCLR NOLPT1OSC RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
